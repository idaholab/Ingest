{
  "version": 3,
  "sources": ["../node_modules/global/window.js", "../node_modules/is-function/index.js", "../node_modules/parse-headers/parse-headers.js", "../node_modules/xtend/immutable.js", "../node_modules/xhr/index.js", "../src/upchunk.ts", "../node_modules/src/lib/misc.ts", "../node_modules/src/lib/error-handler.ts", "../node_modules/src/lib/global.ts", "../node_modules/src/lib/warning-handler.ts", "../node_modules/src/lib/warnings.ts", "../node_modules/src/lib/event.ts", "../node_modules/src/lib/dom-exception.ts", "../node_modules/src/lib/event-wrapper.ts", "../node_modules/src/lib/listener.ts", "../node_modules/src/lib/listener-list.ts", "../node_modules/src/lib/listener-list-map.ts", "../node_modules/src/lib/event-target.ts", "../node_modules/src/lib/event-attribute-handler.ts", "../node_modules/src/lib/legacy.ts"],
  "sourcesContent": ["var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n", "module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  if (!fn) {\n    return false\n  }\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n", "var trim = function(string) {\n  return string.replace(/^\\s+|\\s+$/g, '');\n}\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  var headersArr = trim(headers).split('\\n')\n\n  for (var i = 0; i < headersArr.length; i++) {\n    var row = headersArr[i]\n    var index = row.indexOf(':')\n    , key = trim(row.slice(0, index)).toLowerCase()\n    , value = trim(row.slice(index + 1))\n\n    if (typeof(result[key]) === 'undefined') {\n      result[key] = value\n    } else if (isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [ result[key], value ]\n    }\n  }\n\n  return result\n}\n", "module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n", "\"use strict\";\nvar window = require(\"global/window\")\nvar isFunction = require(\"is-function\")\nvar parseHeaders = require(\"parse-headers\")\nvar xtend = require(\"xtend\")\n\nmodule.exports = createXHR\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = \"withCredentials\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function(method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === \"string\") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === \"undefined\"){\n        throw new Error(\"callback argument missing\")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || \"GET\"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\") //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\") //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort(\"timeout\")\n            var e = new Error(\"XMLHttpRequest timeout\")\n            e.code = \"ETIMEDOUT\"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\")\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if (\"beforeSend\" in options &&\n        typeof options.beforeSend === \"function\"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n    try {\n        if (xhr.responseType === \"document\") {\n            return xhr.responseXML\n        }\n        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\"\n        if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n            return xhr.responseXML\n        }\n    } catch (e) {}\n\n    return null\n}\n\nfunction noop() {}\n", "import { EventTarget, Event } from 'event-target-shim';\nimport xhr from 'xhr';\n// NOTE: Need duplicate imports for Typescript version compatibility reasons (CJP)\n/* tslint:disable-next-line no-duplicate-imports */\nimport type { XhrUrlConfig, XhrHeaders, XhrResponse } from 'xhr';\n\ntype XhrResponseLike = Partial<XhrResponse> & Pick<XhrResponse, 'statusCode'>;\n\nconst DEFAULT_CHUNK_SIZE = 30720;\nconst DEFAULT_MAX_CHUNK_SIZE = 512000; // in kB\nconst DEFAULT_MIN_CHUNK_SIZE = 256; // in kB\n\n// Predicate function that returns true if a given `chunkSize` is valid, otherwise false.\n// For `chunkSize` validity, we constrain by a min/max chunk size and conform to GCS:\n// \"The chunk size should be a multiple of 256 KiB (256 x 1024 bytes), unless it's the last\n// chunk that completes the upload.\" (See: https://cloud.google.com/storage/docs/performing-resumable-uploads)\nexport const isValidChunkSize = (\n  chunkSize: any,\n  {\n    minChunkSize = DEFAULT_MIN_CHUNK_SIZE,\n    maxChunkSize = DEFAULT_MAX_CHUNK_SIZE,\n  } = {}\n): chunkSize is number | null | undefined => {\n  return (\n    chunkSize == null ||\n    (typeof chunkSize === 'number' &&\n      chunkSize >= 256 &&\n      chunkSize % 256 === 0 &&\n      chunkSize >= minChunkSize &&\n      chunkSize <= maxChunkSize)\n  );\n};\n\n// Projection function that returns an error associated with invalid `chunkSize` values.\nexport const getChunkSizeError = (\n  chunkSize: any,\n  {\n    minChunkSize = DEFAULT_MIN_CHUNK_SIZE,\n    maxChunkSize = DEFAULT_MAX_CHUNK_SIZE,\n  } = {}\n) => {\n  return new TypeError(\n    `chunkSize ${chunkSize} must be a positive number in multiples of 256, between ${minChunkSize} and ${maxChunkSize}`\n  );\n};\n\nexport type ChunkedStreamIterableOptions = {\n  defaultChunkSize?: number;\n  minChunkSize?: number;\n  maxChunkSize?: number;\n};\n\nexport interface ChunkedIterable extends AsyncIterable<Blob> {\n  chunkSize: number;\n  readonly chunkByteSize: number;\n  readonly minChunkSize: number;\n  readonly maxChunkSize: number;\n  readonly error: Error | undefined;\n}\n\n// An Iterable that accepts a readableStream of binary data (Blob | Uint8Array) and provides\n// an asyncIterator which yields Blob values of the current chunkSize until done. Note that\n// chunkSize may change between iterations.\nexport class ChunkedStreamIterable implements ChunkedIterable {\n  protected _chunkSize: number | undefined;\n  protected defaultChunkSize: number;\n  protected _error: Error | undefined;\n  public readonly minChunkSize: number;\n  public readonly maxChunkSize: number;\n\n  constructor(\n    protected readableStream: ReadableStream<Uint8Array | Blob>,\n    options: ChunkedStreamIterableOptions = {}\n  ) {\n    if (!isValidChunkSize(options.defaultChunkSize, options)) {\n      throw getChunkSizeError(options.defaultChunkSize, options);\n    }\n    this.defaultChunkSize = options.defaultChunkSize ?? DEFAULT_CHUNK_SIZE;\n    this.minChunkSize = options.minChunkSize ?? DEFAULT_MIN_CHUNK_SIZE;\n    this.maxChunkSize = options.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE;\n  }\n\n  get chunkSize() {\n    return this._chunkSize ?? this.defaultChunkSize;\n  }\n\n  set chunkSize(value) {\n    if (!isValidChunkSize(value, this)) {\n      throw getChunkSizeError(value, this);\n    }\n    this._chunkSize = value;\n  }\n\n  get chunkByteSize() {\n    return this.chunkSize * 1024;\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<Blob> {\n    let chunk;\n    const reader = this.readableStream.getReader();\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          // Last chunk, if any bits remain\n          if (chunk) {\n            const outgoingChunk = chunk;\n            chunk = undefined;\n            yield outgoingChunk;\n          }\n          break;\n        }\n\n        const normalizedBlobChunk =\n          value instanceof Uint8Array\n            ? new Blob([value], { type: 'application/octet-stream' })\n            : value;\n\n        chunk = chunk\n          ? new Blob([chunk, normalizedBlobChunk])\n          : normalizedBlobChunk;\n\n        // NOTE: Since we don't know how big the next chunk needs to be, we should\n        // just have a single blob that we \"peel away bytes from\" for each chunk\n        // as we iterate.\n        while (chunk) {\n          if (chunk.size === this.chunkByteSize) {\n            const outgoingChunk = chunk;\n            chunk = undefined;\n            yield outgoingChunk;\n            break;\n          } else if (chunk.size < this.chunkByteSize) {\n            break;\n          } else {\n            const outgoingChunk = chunk.slice(0, this.chunkByteSize);\n            chunk = chunk.slice(this.chunkByteSize);\n            yield outgoingChunk;\n          }\n        }\n      }\n    } catch (e) {\n      // There are edge case errors when attempting to read() from ReadableStream reader.\n      this._error = e;\n    } finally {\n      // Last chunk, if any bits remain\n      if (chunk) {\n        const outgoingChunk = chunk;\n        chunk = undefined;\n        yield outgoingChunk;\n      }\n      reader.releaseLock();\n      return;\n    }\n  }\n}\n\nexport class ChunkedFileIterable implements ChunkedIterable {\n  protected _chunkSize: number | undefined;\n  protected defaultChunkSize: number;\n  protected _error: Error | undefined;\n  public readonly minChunkSize: number;\n  public readonly maxChunkSize: number;\n\n  constructor(\n    protected file: File,\n    options: ChunkedStreamIterableOptions = {}\n  ) {\n    if (!isValidChunkSize(options.defaultChunkSize, options)) {\n      throw getChunkSizeError(options.defaultChunkSize, options);\n    }\n    this.defaultChunkSize = options.defaultChunkSize ?? DEFAULT_CHUNK_SIZE;\n    this.minChunkSize = options.minChunkSize ?? DEFAULT_MIN_CHUNK_SIZE;\n    this.maxChunkSize = options.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE;\n  }\n\n  get chunkSize() {\n    return this._chunkSize ?? this.defaultChunkSize;\n  }\n\n  set chunkSize(value) {\n    if (!isValidChunkSize(value, this)) {\n      throw getChunkSizeError(value, this);\n    }\n    this._chunkSize = value;\n  }\n\n  get chunkByteSize() {\n    return this.chunkSize * 1024;\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<Blob> {\n    const reader = new FileReader();\n    let nextChunkRangeStart = 0;\n    /**\n     * Get portion of the file of x bytes corresponding to chunkSize\n     */\n    const getChunk = () => {\n      return new Promise<Blob | undefined>((resolve) => {\n        if (nextChunkRangeStart >= this.file.size) {\n          resolve(undefined);\n          return;\n        }\n        // We either want to slize a \"chunkByteSize-worth\" of the file or\n        // slice to the end of the file (if less than a \"chunkByteSize-worth\" is left)\n        const length = Math.min(\n          this.chunkByteSize,\n          this.file.size - nextChunkRangeStart\n        );\n        reader.onload = () => {\n          if (reader.result !== null) {\n            resolve(\n              new Blob([reader.result], {\n                type: 'application/octet-stream',\n              })\n            );\n          } else {\n            resolve(undefined);\n          }\n        };\n\n        reader.readAsArrayBuffer(\n          this.file.slice(nextChunkRangeStart, nextChunkRangeStart + length)\n        );\n      });\n    };\n    try {\n      while (true) {\n        const nextChunk = await getChunk();\n        if (!!nextChunk) {\n          nextChunkRangeStart += nextChunk.size;\n          yield nextChunk;\n        } else {\n          break;\n        }\n      }\n    } catch (e) {\n      this._error = e;\n    }\n  }\n}\n\nconst SUCCESSFUL_CHUNK_UPLOAD_CODES = [200, 201, 202, 204, 308];\nconst TEMPORARY_ERROR_CODES = [408, 502, 503, 504]; // These error codes imply a chunk may be retried\nconst RESUME_INCOMPLETE_CODES = [308];\n\ntype UploadPredOptions = {\n  retryCodes?: typeof TEMPORARY_ERROR_CODES;\n  attempts: number;\n  attemptCount: number;\n};\nconst isSuccessfulChunkUpload = (\n  res: XhrResponseLike | undefined,\n  _options?: any\n): res is XhrResponse =>\n  !!res && SUCCESSFUL_CHUNK_UPLOAD_CODES.includes(res.statusCode);\n\nconst isRetriableChunkUpload = (\n  res: XhrResponseLike | undefined,\n  { retryCodes = TEMPORARY_ERROR_CODES }: UploadPredOptions\n) => !res || retryCodes.includes(res.statusCode);\n\nconst isFailedChunkUpload = (\n  res: XhrResponseLike | undefined,\n  options: UploadPredOptions\n): res is XhrResponseLike => {\n  return (\n    options.attemptCount >= options.attempts ||\n    !(isSuccessfulChunkUpload(res) || isRetriableChunkUpload(res, options))\n  );\n};\n\n/**\n * Checks if an upload chunk was partially received (HTTP 308) and needs a retry.\n * Validates against the 'Range' header to ensure the full chunk was processed.\n */\nexport const isIncompleteChunkUploadNeedingRetry = (\n  res: XhrResponseLike | undefined,\n  _options?: any\n): res is XhrResponseLike => {\n  if (\n    !res ||\n    !RESUME_INCOMPLETE_CODES.includes(res.statusCode) ||\n    !res.headers?.['range']\n  ) {\n    return false;\n  }\n\n  const range = res.headers['range'].match(/bytes=(\\d+)-(\\d+)/);\n  if (!range) {\n    return false;\n  }\n\n  const endByte = parseInt(range[2], 10);\n  return endByte !== _options.currentChunkEndByte;\n};\n\ntype EventName =\n  | 'attempt'\n  | 'attemptFailure'\n  | 'chunkSuccess'\n  | 'error'\n  | 'offline'\n  | 'online'\n  | 'progress'\n  | 'success';\n\n// NOTE: This and the EventTarget definition below could be more precise\n// by e.g. typing the detail of the CustomEvent per EventName.\ntype UpchunkEvent = CustomEvent & Event<EventName>;\n\ntype AllowedMethods = 'PUT' | 'POST' | 'PATCH';\n\nexport interface UpChunkOptions {\n  endpoint: string | ((file?: File) => Promise<string>);\n  file: File;\n  method?: AllowedMethods;\n  headers?: XhrHeaders | (() => XhrHeaders) | (() => Promise<XhrHeaders>);\n  maxFileSize?: number;\n  chunkSize?: number;\n  attempts?: number;\n  delayBeforeAttempt?: number;\n  retryCodes?: number[];\n  dynamicChunkSize?: boolean;\n  maxChunkSize?: number;\n  minChunkSize?: number;\n  useLargeFileWorkaround?: boolean;\n}\n\nexport class UpChunk {\n  public static createUpload(options: UpChunkOptions) {\n    return new UpChunk(options);\n  }\n\n  public endpoint: string | ((file?: File) => Promise<string>);\n  public file: File;\n  public headers: XhrHeaders | (() => XhrHeaders) | (() => Promise<XhrHeaders>);\n  public method: AllowedMethods;\n  public attempts: number;\n  public delayBeforeAttempt: number;\n  public retryCodes: number[];\n  public dynamicChunkSize: boolean;\n  protected chunkedIterable: ChunkedIterable;\n  protected chunkedIterator;\n\n  protected pendingChunk?: Blob;\n  private chunkCount: number;\n  private maxFileBytes: number;\n  private endpointValue: string;\n  private totalChunks: number;\n  private attemptCount: number;\n  private _offline: boolean;\n  private _paused: boolean;\n  private success: boolean;\n  private currentXhr?: XMLHttpRequest;\n  private lastChunkStart: Date;\n  private nextChunkRangeStart: number;\n\n  private eventTarget: EventTarget<Record<EventName, UpchunkEvent>>;\n\n  constructor(options: UpChunkOptions) {\n    this.eventTarget = new EventTarget();\n\n    this.endpoint = options.endpoint;\n    this.file = options.file;\n\n    this.headers = options.headers || ({} as XhrHeaders);\n    this.method = options.method || 'PUT';\n    this.attempts = options.attempts || 5;\n    this.delayBeforeAttempt = options.delayBeforeAttempt || 1;\n    this.retryCodes = options.retryCodes || TEMPORARY_ERROR_CODES;\n    this.dynamicChunkSize = options.dynamicChunkSize || false;\n\n    this.maxFileBytes = (options.maxFileSize || 0) * 1024;\n    this.chunkCount = 0;\n    this.attemptCount = 0;\n    // Initialize offline to the current offline state, where\n    // offline is false if\n    // 1. we're not running in the browser (aka window is undefined) -OR-\n    // 2. we're not online (as advertised by navigator.onLine)\n    this._offline = typeof window !== 'undefined' && !window.navigator.onLine;\n    this._paused = false;\n    this.success = false;\n    this.nextChunkRangeStart = 0;\n\n    if (options.useLargeFileWorkaround) {\n      const readableStreamErrorCallback = (event: CustomEvent) => {\n        // In this case, assume the error is a result of file reading via ReadableStream.\n        // Retry using ChunkedFileIterable, which reads the file into memory instead\n        // of a stream.\n        if (this.chunkedIterable.error) {\n          console.warn(\n            `Unable to read file of size ${this.file.size} bytes via a ReadableStream. Falling back to in-memory FileReader!`\n          );\n          event.stopImmediatePropagation();\n\n          // Re-set everything up with the fallback iterable and corresponding\n          // iterator\n          this.chunkedIterable = new ChunkedFileIterable(this.file, {\n            ...options,\n            defaultChunkSize: options.chunkSize,\n          });\n          this.chunkedIterator = this.chunkedIterable[Symbol.asyncIterator]();\n          this.getEndpoint().then(() => {\n            this.sendChunks();\n          });\n          this.off('error', readableStreamErrorCallback);\n        }\n      };\n      this.on('error', readableStreamErrorCallback);\n    }\n\n    // Types appear to be getting confused in env setup, using the overloaded NodeJS Blob definition, which uses NodeJS.ReadableStream instead\n    // of the DOM type definitions. For definitions, See consumers.d.ts vs. lib.dom.d.ts. (CJP)\n    this.chunkedIterable = new ChunkedStreamIterable(\n      this.file.stream() as unknown as ReadableStream<Uint8Array>,\n      { ...options, defaultChunkSize: options.chunkSize }\n    );\n    this.chunkedIterator = this.chunkedIterable[Symbol.asyncIterator]();\n\n    // NOTE: Since some of upchunk's properties defer \"source of truth\" to\n    // chunkedIterable, we need to do these after it's been created (CJP).\n    this.totalChunks = Math.ceil(this.file.size / this.chunkByteSize);\n    this.validateOptions();\n\n    this.getEndpoint().then(() => this.sendChunks());\n\n    // restart sync when back online\n    // trigger events when offline/back online\n    if (typeof window !== 'undefined') {\n      window.addEventListener('online', () => {\n        if (!this.offline) return;\n\n        this._offline = false;\n        this.dispatch('online');\n        this.sendChunks();\n      });\n\n      window.addEventListener('offline', () => {\n        if (this.offline) return;\n\n        this._offline = true;\n        this.dispatch('offline');\n      });\n    }\n  }\n\n  protected get maxChunkSize() {\n    return this.chunkedIterable?.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE;\n  }\n\n  protected get minChunkSize() {\n    return this.chunkedIterable?.minChunkSize ?? DEFAULT_MIN_CHUNK_SIZE;\n  }\n\n  public get chunkSize() {\n    return this.chunkedIterable?.chunkSize ?? DEFAULT_CHUNK_SIZE;\n  }\n\n  public set chunkSize(value) {\n    this.chunkedIterable.chunkSize = value;\n  }\n\n  public get chunkByteSize() {\n    return this.chunkedIterable.chunkByteSize;\n  }\n\n  public get totalChunkSize() {\n    return Math.ceil(this.file.size / this.chunkByteSize);\n  }\n\n  /**\n   * Subscribe to an event\n   */\n  public on(eventName: EventName, fn: (event: CustomEvent) => void) {\n    this.eventTarget.addEventListener(eventName, fn as EventListener);\n  }\n\n  /**\n   * Subscribe to an event once\n   */\n  public once(eventName: EventName, fn: (event: CustomEvent) => void) {\n    this.eventTarget.addEventListener(eventName, fn as EventListener, {\n      once: true,\n    });\n  }\n\n  /**\n   * Unsubscribe to an event\n   */\n  public off(eventName: EventName, fn: (event: CustomEvent) => void) {\n    this.eventTarget.removeEventListener(eventName, fn as EventListener);\n  }\n\n  public get offline() {\n    return this._offline;\n  }\n\n  public get paused() {\n    return this._paused;\n  }\n\n  public abort() {\n    this.pause();\n    this.currentXhr?.abort();\n  }\n\n  public pause() {\n    this._paused = true;\n  }\n\n  public resume() {\n    if (this._paused) {\n      this._paused = false;\n\n      this.sendChunks();\n    }\n  }\n\n  public get successfulPercentage() {\n    return this.nextChunkRangeStart / this.file.size;\n  }\n\n  /**\n   * Dispatch an event\n   */\n  private dispatch(eventName: EventName, detail?: any) {\n    const event: UpchunkEvent = new CustomEvent(eventName, {\n      detail,\n    }) as UpchunkEvent;\n\n    this.eventTarget.dispatchEvent(event);\n  }\n\n  /**\n   * Validate options and throw errors if expectations are violated.\n   */\n  private validateOptions() {\n    if (\n      !this.endpoint ||\n      (typeof this.endpoint !== 'function' && typeof this.endpoint !== 'string')\n    ) {\n      throw new TypeError(\n        'endpoint must be defined as a string or a function that returns a promise'\n      );\n    }\n    if (!(this.file instanceof File)) {\n      throw new TypeError('file must be a File object');\n    }\n    if (\n      this.headers &&\n      typeof this.headers !== 'function' &&\n      typeof this.headers !== 'object'\n    ) {\n      throw new TypeError(\n        'headers must be null, an object, or a function that returns an object or a promise'\n      );\n    }\n    if (\n      !isValidChunkSize(this.chunkSize, {\n        maxChunkSize: this.maxChunkSize,\n        minChunkSize: this.minChunkSize,\n      })\n    ) {\n      throw getChunkSizeError(this.chunkSize, {\n        maxChunkSize: this.maxChunkSize,\n        minChunkSize: this.minChunkSize,\n      });\n    }\n    if (\n      this.maxChunkSize &&\n      (typeof this.maxChunkSize !== 'number' ||\n        this.maxChunkSize < 256 ||\n        this.maxChunkSize % 256 !== 0 ||\n        this.maxChunkSize < this.chunkSize ||\n        this.maxChunkSize < this.minChunkSize)\n    ) {\n      throw new TypeError(\n        `maxChunkSize must be a positive number in multiples of 256, and larger than or equal to both ${this.minChunkSize} and ${this.chunkSize}`\n      );\n    }\n    if (\n      this.minChunkSize &&\n      (typeof this.minChunkSize !== 'number' ||\n        this.minChunkSize < 256 ||\n        this.minChunkSize % 256 !== 0 ||\n        this.minChunkSize > this.chunkSize ||\n        this.minChunkSize > this.maxChunkSize)\n    ) {\n      throw new TypeError(\n        `minChunkSize must be a positive number in multiples of 256, and smaller than ${this.chunkSize} and ${this.maxChunkSize}`\n      );\n    }\n    if (this.maxFileBytes > 0 && this.maxFileBytes < this.file.size) {\n      throw new Error(\n        `file size exceeds maximum (${this.file.size} > ${this.maxFileBytes})`\n      );\n    }\n    if (\n      this.attempts &&\n      (typeof this.attempts !== 'number' || this.attempts <= 0)\n    ) {\n      throw new TypeError('retries must be a positive number');\n    }\n    if (\n      this.delayBeforeAttempt &&\n      (typeof this.delayBeforeAttempt !== 'number' ||\n        this.delayBeforeAttempt < 0)\n    ) {\n      throw new TypeError('delayBeforeAttempt must be a positive number');\n    }\n  }\n\n  /**\n   * Endpoint can either be a URL or a function that returns a promise that resolves to a string.\n   */\n  private getEndpoint() {\n    if (typeof this.endpoint === 'string') {\n      this.endpointValue = this.endpoint;\n      return Promise.resolve(this.endpoint);\n    }\n\n    return this.endpoint(this.file).then((value) => {\n      this.endpointValue = value;\n      return this.endpointValue;\n    });\n  }\n\n  private xhrPromise(options: XhrUrlConfig): Promise<XhrResponse> {\n    const beforeSend = (xhrObject: XMLHttpRequest) => {\n      xhrObject.upload.onprogress = (event: ProgressEvent) => {\n        const remainingChunks = this.totalChunks - this.chunkCount;\n        const percentagePerChunk =\n          (this.file.size - this.nextChunkRangeStart) /\n          this.file.size /\n          remainingChunks;\n        const currentChunkProgress =\n          event.loaded / (event.total ?? this.chunkByteSize);\n        const chunkPercentage = currentChunkProgress * percentagePerChunk;\n        // NOTE: Since progress events are \"eager\" and do not (yet) have sufficient context\n        // to \"know\" if the request was e.g. successful, we need to \"recompute\"/\"rewind\"\n        // progress if/when we detect failures. See failedChunkUploadCb(), below. (CJP)\n        this.dispatch(\n          'progress',\n          Math.min((this.successfulPercentage + chunkPercentage) * 100, 100)\n        );\n      };\n    };\n\n    return new Promise((resolve, reject) => {\n      this.currentXhr = xhr({ ...options, beforeSend }, (err, resp) => {\n        this.currentXhr = undefined;\n        // NOTE: For at least some `err` cases, resp will still carry information. We may want to consider passing that on somehow\n        // in our Promise reject (or instead of err) (CJP)\n        // See: https://github.com/naugtur/xhr/blob/master/index.js#L93-L100\n        if (err) {\n          return reject(err);\n        }\n\n        return resolve(resp);\n      });\n    });\n  }\n\n  /**\n   * Send chunk of the file with appropriate headers\n   */\n  protected async sendChunk(chunk: Blob) {\n    const rangeStart = this.nextChunkRangeStart;\n    const rangeEnd = rangeStart + chunk.size - 1;\n    const extraHeaders = await (typeof this.headers === 'function'\n      ? this.headers()\n      : this.headers);\n\n    const headers = {\n      ...extraHeaders,\n      'Content-Type': this.file.type,\n      'Content-Range': `bytes ${rangeStart}-${rangeEnd}/${this.file.size}`,\n    };\n\n    this.dispatch('attempt', {\n      chunkNumber: this.chunkCount,\n      totalChunks: this.totalChunks,\n      chunkSize: this.chunkSize,\n    });\n\n    return this.xhrPromise({\n      headers,\n      url: this.endpointValue,\n      method: this.method,\n      body: chunk,\n    });\n  }\n\n  protected async sendChunkWithRetries(chunk: Blob): Promise<boolean> {\n    // What to do if a chunk was successfully uploaded\n    const successfulChunkUploadCb = async (res: XhrResponse, _chunk?: Blob) => {\n      // Side effects\n      const lastChunkEnd = new Date();\n      const lastChunkInterval =\n        (lastChunkEnd.getTime() - this.lastChunkStart.getTime()) / 1000;\n\n      this.dispatch('chunkSuccess', {\n        chunk: this.chunkCount,\n        chunkSize: this.chunkSize,\n        attempts: this.attemptCount,\n        timeInterval: lastChunkInterval,\n        response: res,\n      });\n\n      this.attemptCount = 0;\n      this.chunkCount = (this.chunkCount ?? 0) + 1;\n      this.nextChunkRangeStart = this.nextChunkRangeStart + this.chunkByteSize;\n      if (this.dynamicChunkSize) {\n        let unevenChunkSize = this.chunkSize;\n        if (lastChunkInterval < 10) {\n          unevenChunkSize = Math.min(this.chunkSize * 2, this.maxChunkSize);\n        } else if (lastChunkInterval > 30) {\n          unevenChunkSize = Math.max(this.chunkSize / 2, this.minChunkSize);\n        }\n        // ensure it's a multiple of 256k\n        this.chunkSize = Math.ceil(unevenChunkSize / 256) * 256;\n\n        // Re-estimate the total number of chunks, by adding the completed\n        // chunks to the remaining chunks\n        const remainingChunks =\n          (this.file.size - this.nextChunkRangeStart) / this.chunkByteSize;\n        this.totalChunks = Math.ceil(this.chunkCount + remainingChunks);\n      }\n\n      return true;\n    };\n\n    // What to do if a chunk upload failed, potentially after retries\n    const failedChunkUploadCb = async (res: XhrResponseLike, _chunk?: Blob) => {\n      this.dispatch('progress', Math.min(this.successfulPercentage * 100, 100));\n      // Side effects\n      this.dispatch('error', {\n        message: `Server responded with ${res.statusCode}. Stopping upload.`,\n        chunk: this.chunkCount,\n        attempts: this.attemptCount,\n        response: res,\n      });\n\n      return false;\n    };\n\n    // What to do if a chunk upload failed but is retriable and hasn't exceeded retry\n    // count\n    const retriableChunkUploadCb = async (\n      res: XhrResponseLike | undefined,\n      _chunk?: Blob\n    ) => {\n      // Side effects\n      this.dispatch('attemptFailure', {\n        message: `An error occured uploading chunk ${this.chunkCount}. ${\n          this.attempts - this.attemptCount\n        } retries left.`,\n        chunkNumber: this.chunkCount,\n        attemptsLeft: this.attempts - this.attemptCount,\n        response: res,\n      });\n\n      return new Promise<boolean>((resolve) => {\n        setTimeout(async () => {\n          // Handle mid-flight _paused/offline cases here by storing the\n          // \"still retriable but yet to be uploaded chunk\" in state.\n          // See also: `sendChunks()`\n          if (this._paused || this.offline) {\n            this.pendingChunk = chunk;\n            resolve(false);\n            return;\n          }\n          const chunkUploadSuccess = await this.sendChunkWithRetries(chunk);\n          resolve(chunkUploadSuccess);\n        }, this.delayBeforeAttempt * 1000);\n      });\n    };\n\n    let res: XhrResponseLike | undefined;\n    try {\n      this.attemptCount = this.attemptCount + 1;\n      this.lastChunkStart = new Date();\n      res = await this.sendChunk(chunk);\n    } catch (err: unknown) {\n      // Account for failed attempts due to becoming offline while making a request.\n      if (typeof (err as any)?.statusCode === 'number') {\n        res = err as XhrResponseLike;\n      }\n    }\n    const options = {\n      retryCodes: this.retryCodes,\n      attemptCount: this.attemptCount,\n      attempts: this.attempts,\n      currentChunkEndByte: this.nextChunkRangeStart + chunk.size - 1, // end byte is inclusive\n    };\n    if (isIncompleteChunkUploadNeedingRetry(res, options)) {\n      return retriableChunkUploadCb(res, chunk);\n    }\n    if (isSuccessfulChunkUpload(res, options)) {\n      return successfulChunkUploadCb(res, chunk);\n    }\n    if (isFailedChunkUpload(res, options)) {\n      return failedChunkUploadCb(res, chunk);\n    }\n    // Retriable case\n    return retriableChunkUploadCb(res, chunk);\n  }\n\n  /**\n   * Manage the whole upload by calling getChunk & sendChunk\n   * handle errors & retries and dispatch events\n   */\n  private async sendChunks() {\n    // A \"pending chunk\" is a chunk that was unsuccessful but still retriable when\n    // uploading was _paused or the env is offline. Since this may be the last chunk,\n    // we account for it outside of the loop.\n    if (this.pendingChunk && !(this._paused || this.offline)) {\n      const chunk = this.pendingChunk;\n      this.pendingChunk = undefined;\n      const chunkUploadSuccess = await this.sendChunkWithRetries(chunk);\n      if (this.success && chunkUploadSuccess) {\n        this.dispatch('success');\n      }\n    }\n\n    while (!(this.success || this._paused || this.offline)) {\n      const { value: chunk, done } = await this.chunkedIterator.next();\n      // NOTE: When `done`, `chunk` is undefined, so default `chunkUploadSuccess`\n      // to be `true` on this condition, otherwise `false`.\n      let chunkUploadSuccess = !chunk && done;\n      if (chunk) {\n        chunkUploadSuccess = await this.sendChunkWithRetries(chunk);\n      }\n\n      if (this.chunkedIterable.error) {\n        chunkUploadSuccess = false;\n        this.dispatch('error', {\n          message: `Unable to read file of size ${this.file.size} bytes. Try loading from another browser.`,\n        });\n        return;\n      }\n      // NOTE: Need to disambiguate \"last chunk to upload\" (done) vs. \"successfully\"\n      // uploaded last chunk to upload\" (depends on status of sendChunkWithRetries),\n      // specifically for \"pending chunk\" cases for the last chunk.\n      this.success = !!done;\n      if (this.success && chunkUploadSuccess) {\n        this.dispatch('success');\n      }\n      if (!chunkUploadSuccess) {\n        return;\n      }\n    }\n  }\n}\n\nexport function createUpload(options: UpChunkOptions) {\n  return UpChunk.createUpload(options);\n}\n", "/**\n * Assert a condition.\n * @param condition The condition that it should satisfy.\n * @param message The error message.\n * @param args The arguments for replacing placeholders in the message.\n */\nexport function assertType(\n    condition: boolean,\n    message: string,\n    ...args: any[]\n): asserts condition {\n    if (!condition) {\n        throw new TypeError(format(message, args))\n    }\n}\n\n/**\n * Convert a text and arguments to one string.\n * @param message The formating text\n * @param args The arguments.\n */\nexport function format(message: string, args: any[]): string {\n    let i = 0\n    return message.replace(/%[os]/gu, () => anyToString(args[i++]))\n}\n\n/**\n * Convert a value to a string representation.\n * @param x The value to get the string representation.\n */\nexport function anyToString(x: any): string {\n    if (typeof x !== \"object\" || x === null) {\n        return String(x)\n    }\n    return Object.prototype.toString.call(x)\n}\n", "import { anyToString, assertType } from \"./misc\"\n\ndeclare const console: any\ndeclare const dispatchEvent: any\ndeclare const ErrorEvent: any\ndeclare const process: any\n\nlet currentErrorHandler: setErrorHandler.ErrorHandler | undefined\n\n/**\n * Set the error handler.\n * @param value The error handler to set.\n */\nexport function setErrorHandler(\n    value: setErrorHandler.ErrorHandler | undefined,\n): void {\n    assertType(\n        typeof value === \"function\" || value === undefined,\n        \"The error handler must be a function or undefined, but got %o.\",\n        value,\n    )\n    currentErrorHandler = value\n}\nexport namespace setErrorHandler {\n    /**\n     * The error handler.\n     * @param error The thrown error object.\n     */\n    export type ErrorHandler = (error: Error) => void\n}\n\n/**\n * Print a error message.\n * @param maybeError The error object.\n */\nexport function reportError(maybeError: unknown): void {\n    try {\n        const error =\n            maybeError instanceof Error\n                ? maybeError\n                : new Error(anyToString(maybeError))\n\n        // Call the user-defined error handler if exists.\n        if (currentErrorHandler) {\n            currentErrorHandler(error)\n            return\n        }\n\n        // Dispatch an `error` event if this is on a browser.\n        if (\n            typeof dispatchEvent === \"function\" &&\n            typeof ErrorEvent === \"function\"\n        ) {\n            dispatchEvent(\n                new ErrorEvent(\"error\", { error, message: error.message }),\n            )\n        }\n\n        // Emit an `uncaughtException` event if this is on Node.js.\n        //istanbul ignore else\n        else if (\n            typeof process !== \"undefined\" &&\n            typeof process.emit === \"function\"\n        ) {\n            process.emit(\"uncaughtException\", error)\n            return\n        }\n\n        // Otherwise, print the error.\n        console.error(error)\n    } catch {\n        // ignore.\n    }\n}\n", "declare const globalThis: any\ndeclare const window: any\ndeclare const self: any\ndeclare const global: any\n\n/**\n * The global object.\n */\n//istanbul ignore next\nexport const Global: any =\n    typeof window !== \"undefined\"\n        ? window\n        : typeof self !== \"undefined\"\n        ? self\n        : typeof global !== \"undefined\"\n        ? global\n        : typeof globalThis !== \"undefined\"\n        ? globalThis\n        : undefined\n", "import { assertType } from \"./misc\"\n\ndeclare const console: any\n\nlet currentWarnHandler: setWarningHandler.WarningHandler | undefined\n\n/**\n * Set the warning handler.\n * @param value The warning handler to set.\n */\nexport function setWarningHandler(\n    value: setWarningHandler.WarningHandler | undefined,\n): void {\n    assertType(\n        typeof value === \"function\" || value === undefined,\n        \"The warning handler must be a function or undefined, but got %o.\",\n        value,\n    )\n    currentWarnHandler = value\n}\nexport namespace setWarningHandler {\n    /**\n     * The warning information.\n     */\n    export interface Warning {\n        /**\n         * The code of this warning.\n         */\n        code: string\n        /**\n         * The message in English.\n         */\n        message: string\n        /**\n         * The arguments for replacing placeholders in the text.\n         */\n        args: any[]\n    }\n\n    /**\n     * The warning handler.\n     * @param warning The warning.\n     */\n    export type WarningHandler = (warning: Warning) => void\n}\n\n/**\n * The warning information.\n */\nexport class Warning<TArgs extends any[]> {\n    readonly code: string\n    readonly message: string\n\n    constructor(code: string, message: string) {\n        this.code = code\n        this.message = message\n    }\n\n    /**\n     * Report this warning.\n     * @param args The arguments of the warning.\n     */\n    warn(...args: TArgs): void {\n        try {\n            // Call the user-defined warning handler if exists.\n            if (currentWarnHandler) {\n                currentWarnHandler({ ...this, args })\n                return\n            }\n\n            // Otherwise, print the warning.\n            const stack = (new Error().stack ?? \"\").replace(\n                /^(?:.+?\\n){2}/gu,\n                \"\\n\",\n            )\n            console.warn(this.message, ...args, stack)\n        } catch {\n            // Ignore.\n        }\n    }\n}\n", "import { EventTarget } from \"./event-target\" // Used as only type, so no circular.\nimport { Warning } from \"./warning-handler\"\n\nexport const InitEventWasCalledWhileDispatching = new Warning<[]>(\n    \"W01\",\n    \"Unable to initialize event under dispatching.\",\n)\n\nexport const FalsyWasAssignedToCancelBubble = new Warning<[]>(\n    \"W02\",\n    \"Assigning any falsy value to 'cancelBubble' property has no effect.\",\n)\n\nexport const TruthyWasAssignedToReturnValue = new Warning<[]>(\n    \"W03\",\n    \"Assigning any truthy value to 'returnValue' property has no effect.\",\n)\n\nexport const NonCancelableEventWasCanceled = new Warning<[]>(\n    \"W04\",\n    \"Unable to preventDefault on non-cancelable events.\",\n)\n\nexport const CanceledInPassiveListener = new Warning<[]>(\n    \"W05\",\n    \"Unable to preventDefault inside passive event listener invocation.\",\n)\n\nexport const EventListenerWasDuplicated = new Warning<\n    [type: \"bubble\" | \"capture\", callback: EventTarget.EventListener<any, any>]\n>(\n    \"W06\",\n    \"An event listener wasn't added because it has been added already: %o, %o\",\n)\n\nexport const OptionWasIgnored = new Warning<\n    [name: \"passive\" | \"once\" | \"signal\"]\n>(\n    \"W07\",\n    \"The %o option value was abandoned because the event listener wasn't added as duplicated.\",\n)\n\nexport const InvalidEventListener = new Warning<\n    [callback: EventTarget.EventListener<any, any> | {} | null | undefined]\n>(\n    \"W08\",\n    \"The 'callback' argument must be a function or an object that has 'handleEvent' method: %o\",\n)\n\nexport const InvalidAttributeHandler = new Warning<\n    [callback: EventTarget.EventListener<any, any> | {}]\n>(\"W09\", \"Event attribute handler must be a function: %o\")\n", "import { EventTarget } from \"./event-target\" // Used as only type, so no circular.\nimport { Global } from \"./global\"\nimport { assertType } from \"./misc\"\nimport {\n    CanceledInPassiveListener,\n    FalsyWasAssignedToCancelBubble,\n    InitEventWasCalledWhileDispatching,\n    NonCancelableEventWasCanceled,\n    TruthyWasAssignedToReturnValue,\n} from \"./warnings\"\n\n/*eslint-disable class-methods-use-this */\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * `EventTarget` shim can control the internal state of this `Event` objects.\n * @see https://dom.spec.whatwg.org/#event\n */\nexport class Event<TEventType extends string = string> {\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    static get NONE(): number {\n        return NONE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    static get CAPTURING_PHASE(): number {\n        return CAPTURING_PHASE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    static get AT_TARGET(): number {\n        return AT_TARGET\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    static get BUBBLING_PHASE(): number {\n        return BUBBLING_PHASE\n    }\n\n    /**\n     * Initialize this event instance.\n     * @param type The type of this event.\n     * @param eventInitDict Options to initialize.\n     * @see https://dom.spec.whatwg.org/#dom-event-event\n     */\n    constructor(type: TEventType, eventInitDict?: Event.EventInit) {\n        Object.defineProperty(this, \"isTrusted\", {\n            value: false,\n            enumerable: true,\n        })\n\n        const opts = eventInitDict ?? {}\n        internalDataMap.set(this, {\n            type: String(type),\n            bubbles: Boolean(opts.bubbles),\n            cancelable: Boolean(opts.cancelable),\n            composed: Boolean(opts.composed),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n            inPassiveListenerFlag: false,\n            dispatchFlag: false,\n            timeStamp: Date.now(),\n        })\n    }\n\n    /**\n     * The type of this event.\n     * @see https://dom.spec.whatwg.org/#dom-event-type\n     */\n    get type(): TEventType {\n        return $(this).type as TEventType\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    get target(): EventTarget | null {\n        return $(this).target\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @deprecated Use the `target` property instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-srcelement\n     */\n    get srcElement(): EventTarget | null {\n        return $(this).target\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    get currentTarget(): EventTarget | null {\n        return $(this).currentTarget\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * This doesn't support node tree.\n     * @see https://dom.spec.whatwg.org/#dom-event-composedpath\n     */\n    composedPath(): EventTarget[] {\n        const currentTarget = $(this).currentTarget\n        if (currentTarget) {\n            return [currentTarget]\n        }\n        return []\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    get NONE(): number {\n        return NONE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    get CAPTURING_PHASE(): number {\n        return CAPTURING_PHASE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    get AT_TARGET(): number {\n        return AT_TARGET\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    get BUBBLING_PHASE(): number {\n        return BUBBLING_PHASE\n    }\n\n    /**\n     * The current event phase.\n     * @see https://dom.spec.whatwg.org/#dom-event-eventphase\n     */\n    get eventPhase(): number {\n        return $(this).dispatchFlag ? 2 : 0\n    }\n\n    /**\n     * Stop event bubbling.\n     * Because this shim doesn't support node tree, this merely changes the `cancelBubble` property value.\n     * @see https://dom.spec.whatwg.org/#dom-event-stoppropagation\n     */\n    stopPropagation(): void {\n        $(this).stopPropagationFlag = true\n    }\n\n    /**\n     * `true` if event bubbling was stopped.\n     * @deprecated\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    get cancelBubble(): boolean {\n        return $(this).stopPropagationFlag\n    }\n\n    /**\n     * Stop event bubbling if `true` is set.\n     * @deprecated Use the `stopPropagation()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    set cancelBubble(value: boolean) {\n        if (value) {\n            $(this).stopPropagationFlag = true\n        } else {\n            FalsyWasAssignedToCancelBubble.warn()\n        }\n    }\n\n    /**\n     * Stop event bubbling and subsequent event listener callings.\n     * @see https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation\n     */\n    stopImmediatePropagation(): void {\n        const data = $(this)\n        data.stopPropagationFlag = data.stopImmediatePropagationFlag = true\n    }\n\n    /**\n     * `true` if this event will bubble.\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbles\n     */\n    get bubbles(): boolean {\n        return $(this).bubbles\n    }\n\n    /**\n     * `true` if this event can be canceled by the `preventDefault()` method.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelable\n     */\n    get cancelable(): boolean {\n        return $(this).cancelable\n    }\n\n    /**\n     * `true` if the default behavior will act.\n     * @deprecated Use the `defaultPrevented` proeprty instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    get returnValue(): boolean {\n        return !$(this).canceledFlag\n    }\n\n    /**\n     * Cancel the default behavior if `false` is set.\n     * @deprecated Use the `preventDefault()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    set returnValue(value: boolean) {\n        if (!value) {\n            setCancelFlag($(this))\n        } else {\n            TruthyWasAssignedToReturnValue.warn()\n        }\n    }\n\n    /**\n     * Cancel the default behavior.\n     * @see https://dom.spec.whatwg.org/#dom-event-preventdefault\n     */\n    preventDefault(): void {\n        setCancelFlag($(this))\n    }\n\n    /**\n     * `true` if the default behavior was canceled.\n     * @see https://dom.spec.whatwg.org/#dom-event-defaultprevented\n     */\n    get defaultPrevented(): boolean {\n        return $(this).canceledFlag\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    get composed(): boolean {\n        return $(this).composed\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-istrusted\n     */\n    //istanbul ignore next\n    get isTrusted(): boolean {\n        return false\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-timestamp\n     */\n    get timeStamp(): number {\n        return $(this).timeStamp\n    }\n\n    /**\n     * @deprecated Don't use this method. The constructor did initialization.\n     */\n    initEvent(type: string, bubbles = false, cancelable = false) {\n        const data = $(this)\n        if (data.dispatchFlag) {\n            InitEventWasCalledWhileDispatching.warn()\n            return\n        }\n\n        internalDataMap.set(this, {\n            ...data,\n            type: String(type),\n            bubbles: Boolean(bubbles),\n            cancelable: Boolean(cancelable),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n        })\n    }\n}\n\n/*eslint-enable class-methods-use-this */\n\nexport namespace Event {\n    /**\n     * The options of the `Event` constructor.\n     * @see https://dom.spec.whatwg.org/#dictdef-eventinit\n     */\n    export interface EventInit {\n        bubbles?: boolean\n        cancelable?: boolean\n        composed?: boolean\n    }\n}\n\nexport { $ as getEventInternalData }\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NONE = 0\nconst CAPTURING_PHASE = 1\nconst AT_TARGET = 2\nconst BUBBLING_PHASE = 3\n\n/**\n * Private data.\n */\ninterface EventInternalData {\n    /**\n     * The value of `type` attribute.\n     */\n    readonly type: string\n    /**\n     * The value of `bubbles` attribute.\n     */\n    readonly bubbles: boolean\n    /**\n     * The value of `cancelable` attribute.\n     */\n    readonly cancelable: boolean\n    /**\n     * The value of `composed` attribute.\n     */\n    readonly composed: boolean\n    /**\n     * The value of `timeStamp` attribute.\n     */\n    readonly timeStamp: number\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    target: EventTarget | null\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    currentTarget: EventTarget | null\n    /**\n     * @see https://dom.spec.whatwg.org/#stop-propagation-flag\n     */\n    stopPropagationFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#stop-immediate-propagation-flag\n     */\n    stopImmediatePropagationFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#canceled-flag\n     */\n    canceledFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#in-passive-listener-flag\n     */\n    inPassiveListenerFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#dispatch-flag\n     */\n    dispatchFlag: boolean\n}\n\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap<any, EventInternalData>()\n\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(event: unknown, name = \"this\"): EventInternalData {\n    const retv = internalDataMap.get(event)\n    assertType(\n        retv != null,\n        \"'%s' must be an object that Event constructor created, but got another one: %o\",\n        name,\n        event,\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data private data.\n */\nfunction setCancelFlag(data: EventInternalData) {\n    if (data.inPassiveListenerFlag) {\n        CanceledInPassiveListener.warn()\n        return\n    }\n    if (!data.cancelable) {\n        NonCancelableEventWasCanceled.warn()\n        return\n    }\n\n    data.canceledFlag = true\n}\n\n// Set enumerable\nObject.defineProperty(Event, \"NONE\", { enumerable: true })\nObject.defineProperty(Event, \"CAPTURING_PHASE\", { enumerable: true })\nObject.defineProperty(Event, \"AT_TARGET\", { enumerable: true })\nObject.defineProperty(Event, \"BUBBLING_PHASE\", { enumerable: true })\nconst keys = Object.getOwnPropertyNames(Event.prototype)\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue\n    }\n    Object.defineProperty(Event.prototype, keys[i], { enumerable: true })\n}\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, Global.Event.prototype)\n}\n", "import { Global } from \"./global\"\n\n/**\n * Create a new InvalidStateError instance.\n * @param message The error message.\n */\nexport function createInvalidStateError(message: string): Error {\n    if (Global.DOMException) {\n        return new Global.DOMException(message, \"InvalidStateError\")\n    }\n\n    if (DOMException == null) {\n        DOMException = class DOMException extends Error {\n            constructor(msg: string) {\n                super(msg)\n                if ((Error as any).captureStackTrace) {\n                    ;(Error as any).captureStackTrace(this, DOMException)\n                }\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get code() {\n                return 11\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get name() {\n                return \"InvalidStateError\"\n            }\n        }\n        Object.defineProperties(DOMException.prototype, {\n            code: { enumerable: true },\n            name: { enumerable: true },\n        })\n        defineErrorCodeProperties(DOMException)\n        defineErrorCodeProperties(DOMException.prototype)\n    }\n    return new DOMException(message)\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nlet DOMException: { new (message: string): Error } | undefined\n\nconst ErrorCodeMap = {\n    INDEX_SIZE_ERR: 1,\n    DOMSTRING_SIZE_ERR: 2,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    INVALID_CHARACTER_ERR: 5,\n    NO_DATA_ALLOWED_ERR: 6,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INUSE_ATTRIBUTE_ERR: 10,\n    INVALID_STATE_ERR: 11,\n    SYNTAX_ERR: 12,\n    INVALID_MODIFICATION_ERR: 13,\n    NAMESPACE_ERR: 14,\n    INVALID_ACCESS_ERR: 15,\n    VALIDATION_ERR: 16,\n    TYPE_MISMATCH_ERR: 17,\n    SECURITY_ERR: 18,\n    NETWORK_ERR: 19,\n    ABORT_ERR: 20,\n    URL_MISMATCH_ERR: 21,\n    QUOTA_EXCEEDED_ERR: 22,\n    TIMEOUT_ERR: 23,\n    INVALID_NODE_TYPE_ERR: 24,\n    DATA_CLONE_ERR: 25,\n}\ntype ErrorCodeMap = typeof ErrorCodeMap\n\nfunction defineErrorCodeProperties(obj: any): void {\n    const keys = Object.keys(ErrorCodeMap) as (keyof ErrorCodeMap)[]\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        const value = ErrorCodeMap[key]\n        Object.defineProperty(obj, key, {\n            get() {\n                return value\n            },\n            configurable: true,\n            enumerable: true,\n        })\n    }\n}\n", "import { Event } from \"./event\"\nimport { Global } from \"./global\"\nimport { assertType } from \"./misc\"\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * This class controls the internal state of `Event`.\n * @see https://dom.spec.whatwg.org/#interface-event\n */\nexport class EventWrapper<TEventType extends string> extends Event<TEventType> {\n    /**\n     * Wrap a given event object to control states.\n     * @param event The event-like object to wrap.\n     */\n    static wrap<T extends EventLike>(event: T): EventWrapperOf<T> {\n        return new (getWrapperClassOf(event))(event)\n    }\n\n    protected constructor(event: Event<TEventType>) {\n        super(event.type, {\n            bubbles: event.bubbles,\n            cancelable: event.cancelable,\n            composed: event.composed,\n        })\n\n        if (event.cancelBubble) {\n            super.stopPropagation()\n        }\n        if (event.defaultPrevented) {\n            super.preventDefault()\n        }\n\n        internalDataMap.set(this, { original: event })\n\n        // Define accessors\n        const keys = Object.keys(event)\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i]\n            if (!(key in this)) {\n                Object.defineProperty(\n                    this,\n                    key,\n                    defineRedirectDescriptor(event, key),\n                )\n            }\n        }\n    }\n\n    stopPropagation(): void {\n        super.stopPropagation()\n\n        const { original } = $(this)\n        if (\"stopPropagation\" in original) {\n            original.stopPropagation!()\n        }\n    }\n\n    get cancelBubble(): boolean {\n        return super.cancelBubble\n    }\n    set cancelBubble(value: boolean) {\n        super.cancelBubble = value\n\n        const { original } = $(this)\n        if (\"cancelBubble\" in original) {\n            original.cancelBubble = value\n        }\n    }\n\n    stopImmediatePropagation(): void {\n        super.stopImmediatePropagation()\n\n        const { original } = $(this)\n        if (\"stopImmediatePropagation\" in original) {\n            original.stopImmediatePropagation!()\n        }\n    }\n\n    get returnValue(): boolean {\n        return super.returnValue\n    }\n    set returnValue(value: boolean) {\n        super.returnValue = value\n\n        const { original } = $(this)\n        if (\"returnValue\" in original) {\n            original.returnValue = value\n        }\n    }\n\n    preventDefault(): void {\n        super.preventDefault()\n\n        const { original } = $(this)\n        if (\"preventDefault\" in original) {\n            original.preventDefault!()\n        }\n    }\n\n    get timeStamp(): number {\n        const { original } = $(this)\n        if (\"timeStamp\" in original) {\n            return original.timeStamp!\n        }\n        return super.timeStamp\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\ntype EventLike = { readonly type: string } & Partial<Event>\ntype EventWrapperOf<T extends EventLike> = Event<T[\"type\"]> &\n    Omit<T, keyof Event>\n\ninterface EventWrapperInternalData {\n    readonly original: EventLike\n}\n\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap<any, EventWrapperInternalData>()\n\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @returns The private data of the event.\n */\nfunction $(event: unknown): EventWrapperInternalData {\n    const retv = internalDataMap.get(event)\n    assertType(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event,\n    )\n    return retv\n}\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrapperClassCache = new WeakMap()\n\n// Make association for wrappers.\nwrapperClassCache.set(Object.prototype, EventWrapper)\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    wrapperClassCache.set(Global.Event.prototype, EventWrapper)\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param originalEvent The event object to wrap.\n */\nfunction getWrapperClassOf<T extends EventLike>(\n    originalEvent: T,\n): { new (e: T): EventWrapperOf<T> } {\n    const prototype = Object.getPrototypeOf(originalEvent)\n    if (prototype == null) {\n        return EventWrapper as any\n    }\n\n    let wrapper: any = wrapperClassCache.get(prototype)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapperClassOf(prototype), prototype)\n        wrapperClassCache.set(prototype, wrapper)\n    }\n\n    return wrapper\n}\n\n/**\n * Define new wrapper class.\n * @param BaseEventWrapper The base wrapper class.\n * @param originalPrototype The prototype of the original event.\n */\nfunction defineWrapper(BaseEventWrapper: any, originalPrototype: any): any {\n    class CustomEventWrapper extends BaseEventWrapper {}\n\n    const keys = Object.keys(originalPrototype)\n    for (let i = 0; i < keys.length; ++i) {\n        Object.defineProperty(\n            CustomEventWrapper.prototype,\n            keys[i],\n            defineRedirectDescriptor(originalPrototype, keys[i]),\n        )\n    }\n\n    return CustomEventWrapper\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n */\nfunction defineRedirectDescriptor(obj: any, key: string): PropertyDescriptor {\n    const d = Object.getOwnPropertyDescriptor(obj, key)!\n    return {\n        get() {\n            const original: any = $(this).original\n            const value = original[key]\n            if (typeof value === \"function\") {\n                return value.bind(original)\n            }\n            return value\n        },\n        set(value: any) {\n            const original: any = $(this).original\n            original[key] = value\n        },\n        configurable: d.configurable,\n        enumerable: d.enumerable,\n    }\n}\n", "import { reportError } from \"./error-handler\"\nimport { Event } from \"./event\" // Used as only type, so no circular.\nimport { EventTarget } from \"./event-target\" // Used as only type, so no circular.\n\n/**\n * The event listener concept.\n * @see https://dom.spec.whatwg.org/#concept-event-listener\n */\nexport interface Listener {\n    /**\n     * The callback function.\n     */\n    readonly callback: Listener.Callback<any, any>\n    /**\n     * The flags of this listener.\n     * This is writable to add the removed flag.\n     */\n    flags: ListenerFlags\n    /**\n     * The `AbortSignal` to remove this listener.\n     */\n    readonly signal: Listener.AbortSignal | undefined\n    /**\n     * The `abort` event listener for the `signal`.\n     * To remove it from the `signal`.\n     */\n    readonly signalListener: (() => void) | undefined\n}\n\nexport namespace Listener {\n    export type Callback<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > = CallbackFunction<TEventTarget, TEvent> | CallbackObject<TEvent>\n\n    export interface CallbackFunction<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > {\n        (this: TEventTarget, event: TEvent): void\n    }\n\n    export interface CallbackObject<TEvent extends Event> {\n        handleEvent(event: TEvent): void\n    }\n\n    export interface AbortSignal {\n        addEventListener(type: string, callback: Callback<any, Event>): void\n        removeEventListener(type: string, callback: Callback<any, Event>): void\n    }\n}\n\n/**\n * Create a new listener.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n * @param signalListener The abort event listener for the abort signal.\n */\nexport function createListener(\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n    passive: boolean,\n    once: boolean,\n    signal: Listener.AbortSignal | undefined,\n    signalListener: (() => void) | undefined,\n): Listener {\n    return {\n        callback,\n        flags:\n            (capture ? ListenerFlags.Capture : 0) |\n            (passive ? ListenerFlags.Passive : 0) |\n            (once ? ListenerFlags.Once : 0),\n        signal,\n        signalListener,\n    }\n}\n\n/**\n * Set the `removed` flag to the given listener.\n * @param listener The listener to check.\n */\nexport function setRemoved(listener: Listener): void {\n    listener.flags |= ListenerFlags.Removed\n}\n\n/**\n * Check if the given listener has the `capture` flag or not.\n * @param listener The listener to check.\n */\nexport function isCapture(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Capture) === ListenerFlags.Capture\n}\n\n/**\n * Check if the given listener has the `passive` flag or not.\n * @param listener The listener to check.\n */\nexport function isPassive(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Passive) === ListenerFlags.Passive\n}\n\n/**\n * Check if the given listener has the `once` flag or not.\n * @param listener The listener to check.\n */\nexport function isOnce(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Once) === ListenerFlags.Once\n}\n\n/**\n * Check if the given listener has the `removed` flag or not.\n * @param listener The listener to check.\n */\nexport function isRemoved(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Removed) === ListenerFlags.Removed\n}\n\n/**\n * Call an event listener.\n * @param listener The listener to call.\n * @param target The event target object for `thisArg`.\n * @param event The event object for the first argument.\n * @param attribute `true` if this callback is an event attribute handler.\n */\nexport function invokeCallback(\n    { callback }: Listener,\n    target: EventTarget<any, any>,\n    event: Event<any>,\n): void {\n    try {\n        if (typeof callback === \"function\") {\n            callback.call(target, event)\n        } else if (typeof callback.handleEvent === \"function\") {\n            callback.handleEvent(event)\n        }\n    } catch (thrownError) {\n        reportError(thrownError)\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The flags of listeners.\n */\nconst enum ListenerFlags {\n    Capture = 0x01,\n    Passive = 0x02,\n    Once = 0x04,\n    Removed = 0x08,\n}\n", "import { createListener, isCapture, Listener, setRemoved } from \"./listener\"\n\n/**\n * Information of an listener list.\n */\nexport interface ListenerList {\n    /**\n     * The callback function of the event attribute handler.\n     */\n    attrCallback: Listener.CallbackFunction<any, any> | undefined\n    /**\n     * The listener of the event attribute handler.\n     */\n    attrListener: Listener | undefined\n    /**\n     * `true` if the `dispatchEvent` method is traversing the current `listeners` array.\n     */\n    cow: boolean\n    /**\n     * The listeners.\n     * This is writable for copy-on-write.\n     */\n    listeners: Listener[]\n}\n\n/**\n * Find the index of given listener.\n * This returns `-1` if not found.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n */\nexport function findIndexOfListener(\n    { listeners }: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n): number {\n    for (let i = 0; i < listeners.length; ++i) {\n        if (\n            listeners[i].callback === callback &&\n            isCapture(listeners[i]) === capture\n        ) {\n            return i\n        }\n    }\n    return -1\n}\n\n/**\n * Add the given listener.\n * Does copy-on-write if needed.\n * @param list The listener list.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n */\nexport function addListener(\n    list: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n    passive: boolean,\n    once: boolean,\n    signal: Listener.AbortSignal | undefined,\n): Listener {\n    let signalListener: (() => void) | undefined\n    if (signal) {\n        signalListener = removeListener.bind(null, list, callback, capture)\n        signal.addEventListener(\"abort\", signalListener)\n    }\n\n    const listener = createListener(\n        callback,\n        capture,\n        passive,\n        once,\n        signal,\n        signalListener,\n    )\n\n    if (list.cow) {\n        list.cow = false\n        list.listeners = [...list.listeners, listener]\n    } else {\n        list.listeners.push(listener)\n    }\n\n    return listener\n}\n\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n * @returns `true` if it mutated the list directly.\n */\nexport function removeListener(\n    list: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n): boolean {\n    const index = findIndexOfListener(list, callback, capture)\n    if (index !== -1) {\n        return removeListenerAt(list, index)\n    }\n    return false\n}\n\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param index The index of the target listener.\n * @param disableCow Disable copy-on-write if true.\n * @returns `true` if it mutated the `listeners` array directly.\n */\nexport function removeListenerAt(\n    list: ListenerList,\n    index: number,\n    disableCow = false,\n): boolean {\n    const listener = list.listeners[index]\n\n    // Set the removed flag.\n    setRemoved(listener)\n\n    // Dispose the abort signal listener if exists.\n    if (listener.signal) {\n        listener.signal.removeEventListener(\"abort\", listener.signalListener!)\n    }\n\n    // Remove it from the array.\n    if (list.cow && !disableCow) {\n        list.cow = false\n        list.listeners = list.listeners.filter((_, i) => i !== index)\n        return false\n    }\n    list.listeners.splice(index, 1)\n    return true\n}\n", "import { ListenerList } from \"./listener-list\"\n\n/**\n * The map from event types to each listener list.\n */\nexport interface ListenerListMap {\n    [type: string]: ListenerList | undefined\n}\n\n/**\n * Create a new `ListenerListMap` object.\n */\nexport function createListenerListMap(): ListenerListMap {\n    return Object.create(null)\n}\n\n/**\n * Get the listener list of the given type.\n * If the listener list has not been initialized, initialize and return it.\n * @param listenerMap The listener list map.\n * @param type The event type to get.\n */\nexport function ensureListenerList(\n    listenerMap: Record<string, ListenerList | undefined>,\n    type: string,\n): ListenerList {\n    return (listenerMap[type] ??= {\n        attrCallback: undefined,\n        attrListener: undefined,\n        cow: false,\n        listeners: [],\n    })\n}\n", "import { createInvalidStateError } from \"./dom-exception\"\nimport { Event, getEventInternalData } from \"./event\"\nimport { EventWrapper } from \"./event-wrapper\"\nimport { Global } from \"./global\"\nimport {\n    invokeCallback,\n    isCapture,\n    isOnce,\n    isPassive,\n    isRemoved,\n    Listener,\n} from \"./listener\"\nimport {\n    addListener,\n    findIndexOfListener,\n    removeListener,\n    removeListenerAt,\n} from \"./listener-list\"\nimport {\n    createListenerListMap,\n    ensureListenerList,\n    ListenerListMap,\n} from \"./listener-list-map\"\nimport { assertType, format } from \"./misc\"\nimport {\n    EventListenerWasDuplicated,\n    InvalidEventListener,\n    OptionWasIgnored,\n} from \"./warnings\"\n\n/**\n * An implementation of the `EventTarget` interface.\n * @see https://dom.spec.whatwg.org/#eventtarget\n */\nexport class EventTarget<\n    TEventMap extends Record<string, Event> = Record<string, Event>,\n    TMode extends \"standard\" | \"strict\" = \"standard\"\n> {\n    /**\n     * Initialize this instance.\n     */\n    constructor() {\n        internalDataMap.set(this, createListenerListMap())\n    }\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    addEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options?: EventTarget.AddOptions,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    addEventListener(\n        type: string,\n        callback?: EventTarget.FallbackEventListener<this, TMode>,\n        options?: EventTarget.AddOptions,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    addEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback:\n            | EventTarget.EventListener<this, TEventMap[T]>\n            | null\n            | undefined,\n        capture: boolean,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    addEventListener(\n        type: string,\n        callback: EventTarget.FallbackEventListener<this, TMode>,\n        capture: boolean,\n    ): void\n\n    // Implementation\n    addEventListener<T extends string & keyof TEventMap>(\n        type0: T,\n        callback0?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options0?: boolean | EventTarget.AddOptions,\n    ): void {\n        const listenerMap = $(this)\n        const {\n            callback,\n            capture,\n            once,\n            passive,\n            signal,\n            type,\n        } = normalizeAddOptions(type0, callback0, options0)\n        if (callback == null || signal?.aborted) {\n            return\n        }\n        const list = ensureListenerList(listenerMap, type)\n\n        // Find existing listener.\n        const i = findIndexOfListener(list, callback, capture)\n        if (i !== -1) {\n            warnDuplicate(list.listeners[i], passive, once, signal)\n            return\n        }\n\n        // Add the new listener.\n        addListener(list, callback, capture, passive, once, signal)\n    }\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    removeEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options?: EventTarget.Options,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    removeEventListener(\n        type: string,\n        callback?: EventTarget.FallbackEventListener<this, TMode>,\n        options?: EventTarget.Options,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    removeEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback:\n            | EventTarget.EventListener<this, TEventMap[T]>\n            | null\n            | undefined,\n        capture: boolean,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    removeEventListener(\n        type: string,\n        callback: EventTarget.FallbackEventListener<this, TMode>,\n        capture: boolean,\n    ): void\n\n    // Implementation\n    removeEventListener<T extends string & keyof TEventMap>(\n        type0: T,\n        callback0?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options0?: boolean | EventTarget.Options,\n    ): void {\n        const listenerMap = $(this)\n        const { callback, capture, type } = normalizeOptions(\n            type0,\n            callback0,\n            options0,\n        )\n        const list = listenerMap[type]\n\n        if (callback != null && list) {\n            removeListener(list, callback, capture)\n        }\n    }\n\n    /**\n     * Dispatch an event.\n     * @param event The `Event` object to dispatch.\n     */\n    dispatchEvent<T extends string & keyof TEventMap>(\n        event: EventTarget.EventData<TEventMap, TMode, T>,\n    ): boolean\n\n    /**\n     * Dispatch an event.\n     * @param event The `Event` object to dispatch.\n     */\n    dispatchEvent(event: EventTarget.FallbackEvent<TMode>): boolean\n\n    // Implementation\n    dispatchEvent(\n        e:\n            | EventTarget.EventData<TEventMap, TMode, string>\n            | EventTarget.FallbackEvent<TMode>,\n    ): boolean {\n        const list = $(this)[String(e.type)]\n        if (list == null) {\n            return true\n        }\n\n        const event = e instanceof Event ? e : EventWrapper.wrap(e)\n        const eventData = getEventInternalData(event, \"event\")\n        if (eventData.dispatchFlag) {\n            throw createInvalidStateError(\"This event has been in dispatching.\")\n        }\n\n        eventData.dispatchFlag = true\n        eventData.target = eventData.currentTarget = this\n\n        if (!eventData.stopPropagationFlag) {\n            const { cow, listeners } = list\n\n            // Set copy-on-write flag.\n            list.cow = true\n\n            // Call listeners.\n            for (let i = 0; i < listeners.length; ++i) {\n                const listener = listeners[i]\n\n                // Skip if removed.\n                if (isRemoved(listener)) {\n                    continue\n                }\n\n                // Remove this listener if has the `once` flag.\n                if (isOnce(listener) && removeListenerAt(list, i, !cow)) {\n                    // Because this listener was removed, the next index is the\n                    // same as the current value.\n                    i -= 1\n                }\n\n                // Call this listener with the `passive` flag.\n                eventData.inPassiveListenerFlag = isPassive(listener)\n                invokeCallback(listener, this, event)\n                eventData.inPassiveListenerFlag = false\n\n                // Stop if the `event.stopImmediatePropagation()` method was called.\n                if (eventData.stopImmediatePropagationFlag) {\n                    break\n                }\n            }\n\n            // Restore copy-on-write flag.\n            if (!cow) {\n                list.cow = false\n            }\n        }\n\n        eventData.target = null\n        eventData.currentTarget = null\n        eventData.stopImmediatePropagationFlag = false\n        eventData.stopPropagationFlag = false\n        eventData.dispatchFlag = false\n\n        return !eventData.canceledFlag\n    }\n}\n\nexport namespace EventTarget {\n    /**\n     * The event listener.\n     */\n    export type EventListener<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > = CallbackFunction<TEventTarget, TEvent> | CallbackObject<TEvent>\n\n    /**\n     * The event listener function.\n     */\n    export interface CallbackFunction<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > {\n        (this: TEventTarget, event: TEvent): void\n    }\n\n    /**\n     * The event listener object.\n     * @see https://dom.spec.whatwg.org/#callbackdef-eventlistener\n     */\n    export interface CallbackObject<TEvent extends Event> {\n        handleEvent(event: TEvent): void\n    }\n\n    /**\n     * The common options for both `addEventListener` and `removeEventListener` methods.\n     * @see https://dom.spec.whatwg.org/#dictdef-eventlisteneroptions\n     */\n    export interface Options {\n        capture?: boolean\n    }\n\n    /**\n     * The options for the `addEventListener` methods.\n     * @see https://dom.spec.whatwg.org/#dictdef-addeventlisteneroptions\n     */\n    export interface AddOptions extends Options {\n        passive?: boolean\n        once?: boolean\n        signal?: AbortSignal | null | undefined\n    }\n\n    /**\n     * The abort signal.\n     * @see https://dom.spec.whatwg.org/#abortsignal\n     */\n    export interface AbortSignal extends EventTarget<{ abort: Event }> {\n        readonly aborted: boolean\n        onabort: CallbackFunction<this, Event> | null\n    }\n\n    /**\n     * The event data to dispatch in strict mode.\n     */\n    export type EventData<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\",\n        TEventType extends string\n    > = TMode extends \"strict\"\n        ? IsValidEventMap<TEventMap> extends true\n            ? ExplicitType<TEventType> &\n                  Omit<TEventMap[TEventType], keyof Event> &\n                  Partial<Omit<Event, \"type\">>\n            : never\n        : never\n\n    /**\n     * Define explicit `type` property if `T` is a string literal.\n     * Otherwise, never.\n     */\n    export type ExplicitType<T extends string> = string extends T\n        ? never\n        : { readonly type: T }\n\n    /**\n     * The event listener type in standard mode.\n     * Otherwise, never.\n     */\n    export type FallbackEventListener<\n        TEventTarget extends EventTarget<any, any>,\n        TMode extends \"standard\" | \"strict\"\n    > = TMode extends \"standard\"\n        ? EventListener<TEventTarget, Event> | null | undefined\n        : never\n\n    /**\n     * The event type in standard mode.\n     * Otherwise, never.\n     */\n    export type FallbackEvent<\n        TMode extends \"standard\" | \"strict\"\n    > = TMode extends \"standard\" ? Event : never\n\n    /**\n     * Check if given event map is valid.\n     * It's valid if the keys of the event map are narrower than `string`.\n     */\n    export type IsValidEventMap<T> = string extends keyof T ? false : true\n}\n\nexport { $ as getEventTargetInternalData }\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Internal data for EventTarget\n */\ntype EventTargetInternalData = ListenerListMap\n\n/**\n * Internal data.\n */\nconst internalDataMap = new WeakMap<any, EventTargetInternalData>()\n\n/**\n * Get private data.\n * @param target The event target object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(target: any, name = \"this\"): EventTargetInternalData {\n    const retv = internalDataMap.get(target)\n    assertType(\n        retv != null,\n        \"'%s' must be an object that EventTarget constructor created, but got another one: %o\",\n        name,\n        target,\n    )\n    return retv\n}\n\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeAddOptions(\n    type: string,\n    callback: EventTarget.EventListener<any, any> | null | undefined,\n    options: boolean | EventTarget.AddOptions | undefined,\n): {\n    type: string\n    callback: EventTarget.EventListener<any, any> | undefined\n    capture: boolean\n    passive: boolean\n    once: boolean\n    signal: EventTarget.AbortSignal | undefined\n} {\n    assertCallback(callback)\n\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback ?? undefined,\n            capture: Boolean(options.capture),\n            passive: Boolean(options.passive),\n            once: Boolean(options.once),\n            signal: options.signal ?? undefined,\n        }\n    }\n\n    return {\n        type: String(type),\n        callback: callback ?? undefined,\n        capture: Boolean(options),\n        passive: false,\n        once: false,\n        signal: undefined,\n    }\n}\n\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeOptions(\n    type: string,\n    callback: EventTarget.EventListener<any, any> | null | undefined,\n    options: boolean | EventTarget.Options | undefined,\n): {\n    type: string\n    callback: EventTarget.EventListener<any, any> | undefined\n    capture: boolean\n} {\n    assertCallback(callback)\n\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback ?? undefined,\n            capture: Boolean(options.capture),\n        }\n    }\n\n    return {\n        type: String(type),\n        callback: callback ?? undefined,\n        capture: Boolean(options),\n    }\n}\n\n/**\n * Assert the type of 'callback' argument.\n * @param callback The callback to check.\n */\nfunction assertCallback(callback: any): void {\n    if (\n        typeof callback === \"function\" ||\n        (typeof callback === \"object\" &&\n            callback !== null &&\n            typeof callback.handleEvent === \"function\")\n    ) {\n        return\n    }\n    if (callback == null || typeof callback === \"object\") {\n        InvalidEventListener.warn(callback)\n        return\n    }\n\n    throw new TypeError(format(InvalidEventListener.message, [callback]))\n}\n\n/**\n * Print warning for duplicated.\n * @param listener The current listener that is duplicated.\n * @param passive The passive flag of the new duplicated listener.\n * @param once The once flag of the new duplicated listener.\n * @param signal The signal object of the new duplicated listener.\n */\nfunction warnDuplicate(\n    listener: Listener,\n    passive: boolean,\n    once: boolean,\n    signal: EventTarget.AbortSignal | undefined,\n): void {\n    EventListenerWasDuplicated.warn(\n        isCapture(listener) ? \"capture\" : \"bubble\",\n        listener.callback,\n    )\n\n    if (isPassive(listener) !== passive) {\n        OptionWasIgnored.warn(\"passive\")\n    }\n    if (isOnce(listener) !== once) {\n        OptionWasIgnored.warn(\"once\")\n    }\n    if (listener.signal !== signal) {\n        OptionWasIgnored.warn(\"signal\")\n    }\n}\n\n// Set enumerable\nconst keys = Object.getOwnPropertyNames(EventTarget.prototype)\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue\n    }\n    Object.defineProperty(EventTarget.prototype, keys[i], { enumerable: true })\n}\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof Global !== \"undefined\" &&\n    typeof Global.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype)\n}\n", "import { Event } from \"./event\"\nimport { EventTarget, getEventTargetInternalData } from \"./event-target\"\nimport { addListener, ListenerList, removeListener } from \"./listener-list\"\nimport { ensureListenerList } from \"./listener-list-map\"\nimport { InvalidAttributeHandler } from \"./warnings\"\n\n/**\n * Get the current value of a given event attribute.\n * @param target The `EventTarget` object to get.\n * @param type The event type.\n */\nexport function getEventAttributeValue<\n    TEventTarget extends EventTarget<any, any>,\n    TEvent extends Event\n>(\n    target: TEventTarget,\n    type: string,\n): EventTarget.CallbackFunction<TEventTarget, TEvent> | null {\n    const listMap = getEventTargetInternalData(target, \"target\")\n    return listMap[type]?.attrCallback ?? null\n}\n\n/**\n * Set an event listener to a given event attribute.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nexport function setEventAttributeValue(\n    target: EventTarget<any, any>,\n    type: string,\n    callback: EventTarget.CallbackFunction<any, any> | null,\n): void {\n    if (callback != null && typeof callback !== \"function\") {\n        InvalidAttributeHandler.warn(callback)\n    }\n\n    if (\n        typeof callback === \"function\" ||\n        (typeof callback === \"object\" && callback !== null)\n    ) {\n        upsertEventAttributeListener(target, type, callback)\n    } else {\n        removeEventAttributeListener(target, type)\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Update or insert the given event attribute handler.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction upsertEventAttributeListener<\n    TEventTarget extends EventTarget<any, any>\n>(\n    target: TEventTarget,\n    type: string,\n    callback: EventTarget.CallbackFunction<TEventTarget, any>,\n): void {\n    const list = ensureListenerList(\n        getEventTargetInternalData(target, \"target\"),\n        String(type),\n    )\n    list.attrCallback = callback\n\n    if (list.attrListener == null) {\n        list.attrListener = addListener(\n            list,\n            defineEventAttributeCallback(list),\n            false,\n            false,\n            false,\n            undefined,\n        )\n    }\n}\n\n/**\n * Remove the given event attribute handler.\n * @param target The `EventTarget` object to remove.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction removeEventAttributeListener(\n    target: EventTarget<any, any>,\n    type: string,\n): void {\n    const listMap = getEventTargetInternalData(target, \"target\")\n    const list = listMap[String(type)]\n    if (list && list.attrListener) {\n        removeListener(list, list.attrListener.callback, false)\n        list.attrCallback = list.attrListener = undefined\n    }\n}\n\n/**\n * Define the callback function for the given listener list object.\n * It calls `attrCallback` property if the property value is a function.\n * @param list The `ListenerList` object.\n */\nfunction defineEventAttributeCallback(\n    list: ListenerList,\n): EventTarget.CallbackFunction<any, any> {\n    return function (event) {\n        const callback = list.attrCallback\n        if (typeof callback === \"function\") {\n            callback.call(this, event)\n        }\n    }\n}\n", "import { Event } from \"./event\"\nimport {\n    getEventAttributeValue,\n    setEventAttributeValue,\n} from \"./event-attribute-handler\"\nimport { EventTarget } from \"./event-target\"\n\n/**\n * Define an `EventTarget` class that has event attibutes.\n * @param types The types to define event attributes.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nexport function defineCustomEventTarget<\n    TEventMap extends Record<string, Event>,\n    TMode extends \"standard\" | \"strict\" = \"standard\"\n>(\n    ...types: (string & keyof TEventMap)[]\n): defineCustomEventTarget.CustomEventTargetConstructor<TEventMap, TMode> {\n    class CustomEventTarget extends EventTarget {}\n    for (let i = 0; i < types.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, types[i])\n    }\n\n    return CustomEventTarget as any\n}\n\nexport namespace defineCustomEventTarget {\n    /**\n     * The interface of CustomEventTarget constructor.\n     */\n    export type CustomEventTargetConstructor<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\"\n    > = {\n        /**\n         * Create a new instance.\n         */\n        new (): CustomEventTarget<TEventMap, TMode>\n        /**\n         * prototype object.\n         */\n        prototype: CustomEventTarget<TEventMap, TMode>\n    }\n\n    /**\n     * The interface of CustomEventTarget.\n     */\n    export type CustomEventTarget<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\"\n    > = EventTarget<TEventMap, TMode> &\n        defineEventAttribute.EventAttributes<any, TEventMap>\n}\n\n/**\n * Define an event attribute.\n * @param target The `EventTarget` object to define an event attribute.\n * @param type The event type to define.\n * @param _eventClass Unused, but to infer `Event` class type.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nexport function defineEventAttribute<\n    TEventTarget extends EventTarget,\n    TEventType extends string,\n    TEventConstrucor extends typeof Event\n>(\n    target: TEventTarget,\n    type: TEventType,\n    _eventClass?: TEventConstrucor,\n): asserts target is TEventTarget &\n    defineEventAttribute.EventAttributes<\n        TEventTarget,\n        Record<TEventType, InstanceType<TEventConstrucor>>\n    > {\n    Object.defineProperty(target, `on${type}`, {\n        get() {\n            return getEventAttributeValue(this, type)\n        },\n        set(value) {\n            setEventAttributeValue(this, type, value)\n        },\n        configurable: true,\n        enumerable: true,\n    })\n}\n\nexport namespace defineEventAttribute {\n    /**\n     * Definition of event attributes.\n     */\n    export type EventAttributes<\n        TEventTarget extends EventTarget<any, any>,\n        TEventMap extends Record<string, Event>\n    > = {\n        [P in string &\n            keyof TEventMap as `on${P}`]: EventTarget.CallbackFunction<\n            TEventTarget,\n            TEventMap[P]\n        > | null\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
