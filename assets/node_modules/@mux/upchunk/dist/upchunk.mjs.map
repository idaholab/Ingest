{
  "version": 3,
  "sources": ["../node_modules/global/window.js", "../node_modules/is-function/index.js", "../node_modules/parse-headers/parse-headers.js", "../node_modules/xtend/immutable.js", "../node_modules/xhr/index.js", "../node_modules/src/lib/misc.ts", "../node_modules/src/lib/error-handler.ts", "../node_modules/src/lib/global.ts", "../node_modules/src/lib/warning-handler.ts", "../node_modules/src/lib/warnings.ts", "../node_modules/src/lib/event.ts", "../node_modules/src/lib/dom-exception.ts", "../node_modules/src/lib/event-wrapper.ts", "../node_modules/src/lib/listener.ts", "../node_modules/src/lib/listener-list.ts", "../node_modules/src/lib/listener-list-map.ts", "../node_modules/src/lib/event-target.ts", "../node_modules/src/lib/event-attribute-handler.ts", "../node_modules/src/lib/legacy.ts", "../src/upchunk.ts"],
  "sourcesContent": ["var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n", "module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  if (!fn) {\n    return false\n  }\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n", "var trim = function(string) {\n  return string.replace(/^\\s+|\\s+$/g, '');\n}\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  var headersArr = trim(headers).split('\\n')\n\n  for (var i = 0; i < headersArr.length; i++) {\n    var row = headersArr[i]\n    var index = row.indexOf(':')\n    , key = trim(row.slice(0, index)).toLowerCase()\n    , value = trim(row.slice(index + 1))\n\n    if (typeof(result[key]) === 'undefined') {\n      result[key] = value\n    } else if (isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [ result[key], value ]\n    }\n  }\n\n  return result\n}\n", "module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n", "\"use strict\";\nvar window = require(\"global/window\")\nvar isFunction = require(\"is-function\")\nvar parseHeaders = require(\"parse-headers\")\nvar xtend = require(\"xtend\")\n\nmodule.exports = createXHR\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = \"withCredentials\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function(method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === \"string\") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === \"undefined\"){\n        throw new Error(\"callback argument missing\")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || \"GET\"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\") //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\") //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort(\"timeout\")\n            var e = new Error(\"XMLHttpRequest timeout\")\n            e.code = \"ETIMEDOUT\"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\")\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if (\"beforeSend\" in options &&\n        typeof options.beforeSend === \"function\"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n    try {\n        if (xhr.responseType === \"document\") {\n            return xhr.responseXML\n        }\n        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\"\n        if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n            return xhr.responseXML\n        }\n    } catch (e) {}\n\n    return null\n}\n\nfunction noop() {}\n", "/**\n * Assert a condition.\n * @param condition The condition that it should satisfy.\n * @param message The error message.\n * @param args The arguments for replacing placeholders in the message.\n */\nexport function assertType(\n    condition: boolean,\n    message: string,\n    ...args: any[]\n): asserts condition {\n    if (!condition) {\n        throw new TypeError(format(message, args))\n    }\n}\n\n/**\n * Convert a text and arguments to one string.\n * @param message The formating text\n * @param args The arguments.\n */\nexport function format(message: string, args: any[]): string {\n    let i = 0\n    return message.replace(/%[os]/gu, () => anyToString(args[i++]))\n}\n\n/**\n * Convert a value to a string representation.\n * @param x The value to get the string representation.\n */\nexport function anyToString(x: any): string {\n    if (typeof x !== \"object\" || x === null) {\n        return String(x)\n    }\n    return Object.prototype.toString.call(x)\n}\n", "import { anyToString, assertType } from \"./misc\"\n\ndeclare const console: any\ndeclare const dispatchEvent: any\ndeclare const ErrorEvent: any\ndeclare const process: any\n\nlet currentErrorHandler: setErrorHandler.ErrorHandler | undefined\n\n/**\n * Set the error handler.\n * @param value The error handler to set.\n */\nexport function setErrorHandler(\n    value: setErrorHandler.ErrorHandler | undefined,\n): void {\n    assertType(\n        typeof value === \"function\" || value === undefined,\n        \"The error handler must be a function or undefined, but got %o.\",\n        value,\n    )\n    currentErrorHandler = value\n}\nexport namespace setErrorHandler {\n    /**\n     * The error handler.\n     * @param error The thrown error object.\n     */\n    export type ErrorHandler = (error: Error) => void\n}\n\n/**\n * Print a error message.\n * @param maybeError The error object.\n */\nexport function reportError(maybeError: unknown): void {\n    try {\n        const error =\n            maybeError instanceof Error\n                ? maybeError\n                : new Error(anyToString(maybeError))\n\n        // Call the user-defined error handler if exists.\n        if (currentErrorHandler) {\n            currentErrorHandler(error)\n            return\n        }\n\n        // Dispatch an `error` event if this is on a browser.\n        if (\n            typeof dispatchEvent === \"function\" &&\n            typeof ErrorEvent === \"function\"\n        ) {\n            dispatchEvent(\n                new ErrorEvent(\"error\", { error, message: error.message }),\n            )\n        }\n\n        // Emit an `uncaughtException` event if this is on Node.js.\n        //istanbul ignore else\n        else if (\n            typeof process !== \"undefined\" &&\n            typeof process.emit === \"function\"\n        ) {\n            process.emit(\"uncaughtException\", error)\n            return\n        }\n\n        // Otherwise, print the error.\n        console.error(error)\n    } catch {\n        // ignore.\n    }\n}\n", "declare const globalThis: any\ndeclare const window: any\ndeclare const self: any\ndeclare const global: any\n\n/**\n * The global object.\n */\n//istanbul ignore next\nexport const Global: any =\n    typeof window !== \"undefined\"\n        ? window\n        : typeof self !== \"undefined\"\n        ? self\n        : typeof global !== \"undefined\"\n        ? global\n        : typeof globalThis !== \"undefined\"\n        ? globalThis\n        : undefined\n", "import { assertType } from \"./misc\"\n\ndeclare const console: any\n\nlet currentWarnHandler: setWarningHandler.WarningHandler | undefined\n\n/**\n * Set the warning handler.\n * @param value The warning handler to set.\n */\nexport function setWarningHandler(\n    value: setWarningHandler.WarningHandler | undefined,\n): void {\n    assertType(\n        typeof value === \"function\" || value === undefined,\n        \"The warning handler must be a function or undefined, but got %o.\",\n        value,\n    )\n    currentWarnHandler = value\n}\nexport namespace setWarningHandler {\n    /**\n     * The warning information.\n     */\n    export interface Warning {\n        /**\n         * The code of this warning.\n         */\n        code: string\n        /**\n         * The message in English.\n         */\n        message: string\n        /**\n         * The arguments for replacing placeholders in the text.\n         */\n        args: any[]\n    }\n\n    /**\n     * The warning handler.\n     * @param warning The warning.\n     */\n    export type WarningHandler = (warning: Warning) => void\n}\n\n/**\n * The warning information.\n */\nexport class Warning<TArgs extends any[]> {\n    readonly code: string\n    readonly message: string\n\n    constructor(code: string, message: string) {\n        this.code = code\n        this.message = message\n    }\n\n    /**\n     * Report this warning.\n     * @param args The arguments of the warning.\n     */\n    warn(...args: TArgs): void {\n        try {\n            // Call the user-defined warning handler if exists.\n            if (currentWarnHandler) {\n                currentWarnHandler({ ...this, args })\n                return\n            }\n\n            // Otherwise, print the warning.\n            const stack = (new Error().stack ?? \"\").replace(\n                /^(?:.+?\\n){2}/gu,\n                \"\\n\",\n            )\n            console.warn(this.message, ...args, stack)\n        } catch {\n            // Ignore.\n        }\n    }\n}\n", "import { EventTarget } from \"./event-target\" // Used as only type, so no circular.\nimport { Warning } from \"./warning-handler\"\n\nexport const InitEventWasCalledWhileDispatching = new Warning<[]>(\n    \"W01\",\n    \"Unable to initialize event under dispatching.\",\n)\n\nexport const FalsyWasAssignedToCancelBubble = new Warning<[]>(\n    \"W02\",\n    \"Assigning any falsy value to 'cancelBubble' property has no effect.\",\n)\n\nexport const TruthyWasAssignedToReturnValue = new Warning<[]>(\n    \"W03\",\n    \"Assigning any truthy value to 'returnValue' property has no effect.\",\n)\n\nexport const NonCancelableEventWasCanceled = new Warning<[]>(\n    \"W04\",\n    \"Unable to preventDefault on non-cancelable events.\",\n)\n\nexport const CanceledInPassiveListener = new Warning<[]>(\n    \"W05\",\n    \"Unable to preventDefault inside passive event listener invocation.\",\n)\n\nexport const EventListenerWasDuplicated = new Warning<\n    [type: \"bubble\" | \"capture\", callback: EventTarget.EventListener<any, any>]\n>(\n    \"W06\",\n    \"An event listener wasn't added because it has been added already: %o, %o\",\n)\n\nexport const OptionWasIgnored = new Warning<\n    [name: \"passive\" | \"once\" | \"signal\"]\n>(\n    \"W07\",\n    \"The %o option value was abandoned because the event listener wasn't added as duplicated.\",\n)\n\nexport const InvalidEventListener = new Warning<\n    [callback: EventTarget.EventListener<any, any> | {} | null | undefined]\n>(\n    \"W08\",\n    \"The 'callback' argument must be a function or an object that has 'handleEvent' method: %o\",\n)\n\nexport const InvalidAttributeHandler = new Warning<\n    [callback: EventTarget.EventListener<any, any> | {}]\n>(\"W09\", \"Event attribute handler must be a function: %o\")\n", "import { EventTarget } from \"./event-target\" // Used as only type, so no circular.\nimport { Global } from \"./global\"\nimport { assertType } from \"./misc\"\nimport {\n    CanceledInPassiveListener,\n    FalsyWasAssignedToCancelBubble,\n    InitEventWasCalledWhileDispatching,\n    NonCancelableEventWasCanceled,\n    TruthyWasAssignedToReturnValue,\n} from \"./warnings\"\n\n/*eslint-disable class-methods-use-this */\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * `EventTarget` shim can control the internal state of this `Event` objects.\n * @see https://dom.spec.whatwg.org/#event\n */\nexport class Event<TEventType extends string = string> {\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    static get NONE(): number {\n        return NONE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    static get CAPTURING_PHASE(): number {\n        return CAPTURING_PHASE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    static get AT_TARGET(): number {\n        return AT_TARGET\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    static get BUBBLING_PHASE(): number {\n        return BUBBLING_PHASE\n    }\n\n    /**\n     * Initialize this event instance.\n     * @param type The type of this event.\n     * @param eventInitDict Options to initialize.\n     * @see https://dom.spec.whatwg.org/#dom-event-event\n     */\n    constructor(type: TEventType, eventInitDict?: Event.EventInit) {\n        Object.defineProperty(this, \"isTrusted\", {\n            value: false,\n            enumerable: true,\n        })\n\n        const opts = eventInitDict ?? {}\n        internalDataMap.set(this, {\n            type: String(type),\n            bubbles: Boolean(opts.bubbles),\n            cancelable: Boolean(opts.cancelable),\n            composed: Boolean(opts.composed),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n            inPassiveListenerFlag: false,\n            dispatchFlag: false,\n            timeStamp: Date.now(),\n        })\n    }\n\n    /**\n     * The type of this event.\n     * @see https://dom.spec.whatwg.org/#dom-event-type\n     */\n    get type(): TEventType {\n        return $(this).type as TEventType\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    get target(): EventTarget | null {\n        return $(this).target\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @deprecated Use the `target` property instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-srcelement\n     */\n    get srcElement(): EventTarget | null {\n        return $(this).target\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    get currentTarget(): EventTarget | null {\n        return $(this).currentTarget\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * This doesn't support node tree.\n     * @see https://dom.spec.whatwg.org/#dom-event-composedpath\n     */\n    composedPath(): EventTarget[] {\n        const currentTarget = $(this).currentTarget\n        if (currentTarget) {\n            return [currentTarget]\n        }\n        return []\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    get NONE(): number {\n        return NONE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    get CAPTURING_PHASE(): number {\n        return CAPTURING_PHASE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    get AT_TARGET(): number {\n        return AT_TARGET\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    get BUBBLING_PHASE(): number {\n        return BUBBLING_PHASE\n    }\n\n    /**\n     * The current event phase.\n     * @see https://dom.spec.whatwg.org/#dom-event-eventphase\n     */\n    get eventPhase(): number {\n        return $(this).dispatchFlag ? 2 : 0\n    }\n\n    /**\n     * Stop event bubbling.\n     * Because this shim doesn't support node tree, this merely changes the `cancelBubble` property value.\n     * @see https://dom.spec.whatwg.org/#dom-event-stoppropagation\n     */\n    stopPropagation(): void {\n        $(this).stopPropagationFlag = true\n    }\n\n    /**\n     * `true` if event bubbling was stopped.\n     * @deprecated\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    get cancelBubble(): boolean {\n        return $(this).stopPropagationFlag\n    }\n\n    /**\n     * Stop event bubbling if `true` is set.\n     * @deprecated Use the `stopPropagation()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    set cancelBubble(value: boolean) {\n        if (value) {\n            $(this).stopPropagationFlag = true\n        } else {\n            FalsyWasAssignedToCancelBubble.warn()\n        }\n    }\n\n    /**\n     * Stop event bubbling and subsequent event listener callings.\n     * @see https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation\n     */\n    stopImmediatePropagation(): void {\n        const data = $(this)\n        data.stopPropagationFlag = data.stopImmediatePropagationFlag = true\n    }\n\n    /**\n     * `true` if this event will bubble.\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbles\n     */\n    get bubbles(): boolean {\n        return $(this).bubbles\n    }\n\n    /**\n     * `true` if this event can be canceled by the `preventDefault()` method.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelable\n     */\n    get cancelable(): boolean {\n        return $(this).cancelable\n    }\n\n    /**\n     * `true` if the default behavior will act.\n     * @deprecated Use the `defaultPrevented` proeprty instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    get returnValue(): boolean {\n        return !$(this).canceledFlag\n    }\n\n    /**\n     * Cancel the default behavior if `false` is set.\n     * @deprecated Use the `preventDefault()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    set returnValue(value: boolean) {\n        if (!value) {\n            setCancelFlag($(this))\n        } else {\n            TruthyWasAssignedToReturnValue.warn()\n        }\n    }\n\n    /**\n     * Cancel the default behavior.\n     * @see https://dom.spec.whatwg.org/#dom-event-preventdefault\n     */\n    preventDefault(): void {\n        setCancelFlag($(this))\n    }\n\n    /**\n     * `true` if the default behavior was canceled.\n     * @see https://dom.spec.whatwg.org/#dom-event-defaultprevented\n     */\n    get defaultPrevented(): boolean {\n        return $(this).canceledFlag\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    get composed(): boolean {\n        return $(this).composed\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-istrusted\n     */\n    //istanbul ignore next\n    get isTrusted(): boolean {\n        return false\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-timestamp\n     */\n    get timeStamp(): number {\n        return $(this).timeStamp\n    }\n\n    /**\n     * @deprecated Don't use this method. The constructor did initialization.\n     */\n    initEvent(type: string, bubbles = false, cancelable = false) {\n        const data = $(this)\n        if (data.dispatchFlag) {\n            InitEventWasCalledWhileDispatching.warn()\n            return\n        }\n\n        internalDataMap.set(this, {\n            ...data,\n            type: String(type),\n            bubbles: Boolean(bubbles),\n            cancelable: Boolean(cancelable),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n        })\n    }\n}\n\n/*eslint-enable class-methods-use-this */\n\nexport namespace Event {\n    /**\n     * The options of the `Event` constructor.\n     * @see https://dom.spec.whatwg.org/#dictdef-eventinit\n     */\n    export interface EventInit {\n        bubbles?: boolean\n        cancelable?: boolean\n        composed?: boolean\n    }\n}\n\nexport { $ as getEventInternalData }\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NONE = 0\nconst CAPTURING_PHASE = 1\nconst AT_TARGET = 2\nconst BUBBLING_PHASE = 3\n\n/**\n * Private data.\n */\ninterface EventInternalData {\n    /**\n     * The value of `type` attribute.\n     */\n    readonly type: string\n    /**\n     * The value of `bubbles` attribute.\n     */\n    readonly bubbles: boolean\n    /**\n     * The value of `cancelable` attribute.\n     */\n    readonly cancelable: boolean\n    /**\n     * The value of `composed` attribute.\n     */\n    readonly composed: boolean\n    /**\n     * The value of `timeStamp` attribute.\n     */\n    readonly timeStamp: number\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    target: EventTarget | null\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    currentTarget: EventTarget | null\n    /**\n     * @see https://dom.spec.whatwg.org/#stop-propagation-flag\n     */\n    stopPropagationFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#stop-immediate-propagation-flag\n     */\n    stopImmediatePropagationFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#canceled-flag\n     */\n    canceledFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#in-passive-listener-flag\n     */\n    inPassiveListenerFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#dispatch-flag\n     */\n    dispatchFlag: boolean\n}\n\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap<any, EventInternalData>()\n\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(event: unknown, name = \"this\"): EventInternalData {\n    const retv = internalDataMap.get(event)\n    assertType(\n        retv != null,\n        \"'%s' must be an object that Event constructor created, but got another one: %o\",\n        name,\n        event,\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data private data.\n */\nfunction setCancelFlag(data: EventInternalData) {\n    if (data.inPassiveListenerFlag) {\n        CanceledInPassiveListener.warn()\n        return\n    }\n    if (!data.cancelable) {\n        NonCancelableEventWasCanceled.warn()\n        return\n    }\n\n    data.canceledFlag = true\n}\n\n// Set enumerable\nObject.defineProperty(Event, \"NONE\", { enumerable: true })\nObject.defineProperty(Event, \"CAPTURING_PHASE\", { enumerable: true })\nObject.defineProperty(Event, \"AT_TARGET\", { enumerable: true })\nObject.defineProperty(Event, \"BUBBLING_PHASE\", { enumerable: true })\nconst keys = Object.getOwnPropertyNames(Event.prototype)\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue\n    }\n    Object.defineProperty(Event.prototype, keys[i], { enumerable: true })\n}\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, Global.Event.prototype)\n}\n", "import { Global } from \"./global\"\n\n/**\n * Create a new InvalidStateError instance.\n * @param message The error message.\n */\nexport function createInvalidStateError(message: string): Error {\n    if (Global.DOMException) {\n        return new Global.DOMException(message, \"InvalidStateError\")\n    }\n\n    if (DOMException == null) {\n        DOMException = class DOMException extends Error {\n            constructor(msg: string) {\n                super(msg)\n                if ((Error as any).captureStackTrace) {\n                    ;(Error as any).captureStackTrace(this, DOMException)\n                }\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get code() {\n                return 11\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get name() {\n                return \"InvalidStateError\"\n            }\n        }\n        Object.defineProperties(DOMException.prototype, {\n            code: { enumerable: true },\n            name: { enumerable: true },\n        })\n        defineErrorCodeProperties(DOMException)\n        defineErrorCodeProperties(DOMException.prototype)\n    }\n    return new DOMException(message)\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nlet DOMException: { new (message: string): Error } | undefined\n\nconst ErrorCodeMap = {\n    INDEX_SIZE_ERR: 1,\n    DOMSTRING_SIZE_ERR: 2,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    INVALID_CHARACTER_ERR: 5,\n    NO_DATA_ALLOWED_ERR: 6,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INUSE_ATTRIBUTE_ERR: 10,\n    INVALID_STATE_ERR: 11,\n    SYNTAX_ERR: 12,\n    INVALID_MODIFICATION_ERR: 13,\n    NAMESPACE_ERR: 14,\n    INVALID_ACCESS_ERR: 15,\n    VALIDATION_ERR: 16,\n    TYPE_MISMATCH_ERR: 17,\n    SECURITY_ERR: 18,\n    NETWORK_ERR: 19,\n    ABORT_ERR: 20,\n    URL_MISMATCH_ERR: 21,\n    QUOTA_EXCEEDED_ERR: 22,\n    TIMEOUT_ERR: 23,\n    INVALID_NODE_TYPE_ERR: 24,\n    DATA_CLONE_ERR: 25,\n}\ntype ErrorCodeMap = typeof ErrorCodeMap\n\nfunction defineErrorCodeProperties(obj: any): void {\n    const keys = Object.keys(ErrorCodeMap) as (keyof ErrorCodeMap)[]\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        const value = ErrorCodeMap[key]\n        Object.defineProperty(obj, key, {\n            get() {\n                return value\n            },\n            configurable: true,\n            enumerable: true,\n        })\n    }\n}\n", "import { Event } from \"./event\"\nimport { Global } from \"./global\"\nimport { assertType } from \"./misc\"\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * This class controls the internal state of `Event`.\n * @see https://dom.spec.whatwg.org/#interface-event\n */\nexport class EventWrapper<TEventType extends string> extends Event<TEventType> {\n    /**\n     * Wrap a given event object to control states.\n     * @param event The event-like object to wrap.\n     */\n    static wrap<T extends EventLike>(event: T): EventWrapperOf<T> {\n        return new (getWrapperClassOf(event))(event)\n    }\n\n    protected constructor(event: Event<TEventType>) {\n        super(event.type, {\n            bubbles: event.bubbles,\n            cancelable: event.cancelable,\n            composed: event.composed,\n        })\n\n        if (event.cancelBubble) {\n            super.stopPropagation()\n        }\n        if (event.defaultPrevented) {\n            super.preventDefault()\n        }\n\n        internalDataMap.set(this, { original: event })\n\n        // Define accessors\n        const keys = Object.keys(event)\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i]\n            if (!(key in this)) {\n                Object.defineProperty(\n                    this,\n                    key,\n                    defineRedirectDescriptor(event, key),\n                )\n            }\n        }\n    }\n\n    stopPropagation(): void {\n        super.stopPropagation()\n\n        const { original } = $(this)\n        if (\"stopPropagation\" in original) {\n            original.stopPropagation!()\n        }\n    }\n\n    get cancelBubble(): boolean {\n        return super.cancelBubble\n    }\n    set cancelBubble(value: boolean) {\n        super.cancelBubble = value\n\n        const { original } = $(this)\n        if (\"cancelBubble\" in original) {\n            original.cancelBubble = value\n        }\n    }\n\n    stopImmediatePropagation(): void {\n        super.stopImmediatePropagation()\n\n        const { original } = $(this)\n        if (\"stopImmediatePropagation\" in original) {\n            original.stopImmediatePropagation!()\n        }\n    }\n\n    get returnValue(): boolean {\n        return super.returnValue\n    }\n    set returnValue(value: boolean) {\n        super.returnValue = value\n\n        const { original } = $(this)\n        if (\"returnValue\" in original) {\n            original.returnValue = value\n        }\n    }\n\n    preventDefault(): void {\n        super.preventDefault()\n\n        const { original } = $(this)\n        if (\"preventDefault\" in original) {\n            original.preventDefault!()\n        }\n    }\n\n    get timeStamp(): number {\n        const { original } = $(this)\n        if (\"timeStamp\" in original) {\n            return original.timeStamp!\n        }\n        return super.timeStamp\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\ntype EventLike = { readonly type: string } & Partial<Event>\ntype EventWrapperOf<T extends EventLike> = Event<T[\"type\"]> &\n    Omit<T, keyof Event>\n\ninterface EventWrapperInternalData {\n    readonly original: EventLike\n}\n\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap<any, EventWrapperInternalData>()\n\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @returns The private data of the event.\n */\nfunction $(event: unknown): EventWrapperInternalData {\n    const retv = internalDataMap.get(event)\n    assertType(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event,\n    )\n    return retv\n}\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrapperClassCache = new WeakMap()\n\n// Make association for wrappers.\nwrapperClassCache.set(Object.prototype, EventWrapper)\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    wrapperClassCache.set(Global.Event.prototype, EventWrapper)\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param originalEvent The event object to wrap.\n */\nfunction getWrapperClassOf<T extends EventLike>(\n    originalEvent: T,\n): { new (e: T): EventWrapperOf<T> } {\n    const prototype = Object.getPrototypeOf(originalEvent)\n    if (prototype == null) {\n        return EventWrapper as any\n    }\n\n    let wrapper: any = wrapperClassCache.get(prototype)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapperClassOf(prototype), prototype)\n        wrapperClassCache.set(prototype, wrapper)\n    }\n\n    return wrapper\n}\n\n/**\n * Define new wrapper class.\n * @param BaseEventWrapper The base wrapper class.\n * @param originalPrototype The prototype of the original event.\n */\nfunction defineWrapper(BaseEventWrapper: any, originalPrototype: any): any {\n    class CustomEventWrapper extends BaseEventWrapper {}\n\n    const keys = Object.keys(originalPrototype)\n    for (let i = 0; i < keys.length; ++i) {\n        Object.defineProperty(\n            CustomEventWrapper.prototype,\n            keys[i],\n            defineRedirectDescriptor(originalPrototype, keys[i]),\n        )\n    }\n\n    return CustomEventWrapper\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n */\nfunction defineRedirectDescriptor(obj: any, key: string): PropertyDescriptor {\n    const d = Object.getOwnPropertyDescriptor(obj, key)!\n    return {\n        get() {\n            const original: any = $(this).original\n            const value = original[key]\n            if (typeof value === \"function\") {\n                return value.bind(original)\n            }\n            return value\n        },\n        set(value: any) {\n            const original: any = $(this).original\n            original[key] = value\n        },\n        configurable: d.configurable,\n        enumerable: d.enumerable,\n    }\n}\n", "import { reportError } from \"./error-handler\"\nimport { Event } from \"./event\" // Used as only type, so no circular.\nimport { EventTarget } from \"./event-target\" // Used as only type, so no circular.\n\n/**\n * The event listener concept.\n * @see https://dom.spec.whatwg.org/#concept-event-listener\n */\nexport interface Listener {\n    /**\n     * The callback function.\n     */\n    readonly callback: Listener.Callback<any, any>\n    /**\n     * The flags of this listener.\n     * This is writable to add the removed flag.\n     */\n    flags: ListenerFlags\n    /**\n     * The `AbortSignal` to remove this listener.\n     */\n    readonly signal: Listener.AbortSignal | undefined\n    /**\n     * The `abort` event listener for the `signal`.\n     * To remove it from the `signal`.\n     */\n    readonly signalListener: (() => void) | undefined\n}\n\nexport namespace Listener {\n    export type Callback<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > = CallbackFunction<TEventTarget, TEvent> | CallbackObject<TEvent>\n\n    export interface CallbackFunction<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > {\n        (this: TEventTarget, event: TEvent): void\n    }\n\n    export interface CallbackObject<TEvent extends Event> {\n        handleEvent(event: TEvent): void\n    }\n\n    export interface AbortSignal {\n        addEventListener(type: string, callback: Callback<any, Event>): void\n        removeEventListener(type: string, callback: Callback<any, Event>): void\n    }\n}\n\n/**\n * Create a new listener.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n * @param signalListener The abort event listener for the abort signal.\n */\nexport function createListener(\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n    passive: boolean,\n    once: boolean,\n    signal: Listener.AbortSignal | undefined,\n    signalListener: (() => void) | undefined,\n): Listener {\n    return {\n        callback,\n        flags:\n            (capture ? ListenerFlags.Capture : 0) |\n            (passive ? ListenerFlags.Passive : 0) |\n            (once ? ListenerFlags.Once : 0),\n        signal,\n        signalListener,\n    }\n}\n\n/**\n * Set the `removed` flag to the given listener.\n * @param listener The listener to check.\n */\nexport function setRemoved(listener: Listener): void {\n    listener.flags |= ListenerFlags.Removed\n}\n\n/**\n * Check if the given listener has the `capture` flag or not.\n * @param listener The listener to check.\n */\nexport function isCapture(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Capture) === ListenerFlags.Capture\n}\n\n/**\n * Check if the given listener has the `passive` flag or not.\n * @param listener The listener to check.\n */\nexport function isPassive(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Passive) === ListenerFlags.Passive\n}\n\n/**\n * Check if the given listener has the `once` flag or not.\n * @param listener The listener to check.\n */\nexport function isOnce(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Once) === ListenerFlags.Once\n}\n\n/**\n * Check if the given listener has the `removed` flag or not.\n * @param listener The listener to check.\n */\nexport function isRemoved(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Removed) === ListenerFlags.Removed\n}\n\n/**\n * Call an event listener.\n * @param listener The listener to call.\n * @param target The event target object for `thisArg`.\n * @param event The event object for the first argument.\n * @param attribute `true` if this callback is an event attribute handler.\n */\nexport function invokeCallback(\n    { callback }: Listener,\n    target: EventTarget<any, any>,\n    event: Event<any>,\n): void {\n    try {\n        if (typeof callback === \"function\") {\n            callback.call(target, event)\n        } else if (typeof callback.handleEvent === \"function\") {\n            callback.handleEvent(event)\n        }\n    } catch (thrownError) {\n        reportError(thrownError)\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The flags of listeners.\n */\nconst enum ListenerFlags {\n    Capture = 0x01,\n    Passive = 0x02,\n    Once = 0x04,\n    Removed = 0x08,\n}\n", "import { createListener, isCapture, Listener, setRemoved } from \"./listener\"\n\n/**\n * Information of an listener list.\n */\nexport interface ListenerList {\n    /**\n     * The callback function of the event attribute handler.\n     */\n    attrCallback: Listener.CallbackFunction<any, any> | undefined\n    /**\n     * The listener of the event attribute handler.\n     */\n    attrListener: Listener | undefined\n    /**\n     * `true` if the `dispatchEvent` method is traversing the current `listeners` array.\n     */\n    cow: boolean\n    /**\n     * The listeners.\n     * This is writable for copy-on-write.\n     */\n    listeners: Listener[]\n}\n\n/**\n * Find the index of given listener.\n * This returns `-1` if not found.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n */\nexport function findIndexOfListener(\n    { listeners }: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n): number {\n    for (let i = 0; i < listeners.length; ++i) {\n        if (\n            listeners[i].callback === callback &&\n            isCapture(listeners[i]) === capture\n        ) {\n            return i\n        }\n    }\n    return -1\n}\n\n/**\n * Add the given listener.\n * Does copy-on-write if needed.\n * @param list The listener list.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n */\nexport function addListener(\n    list: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n    passive: boolean,\n    once: boolean,\n    signal: Listener.AbortSignal | undefined,\n): Listener {\n    let signalListener: (() => void) | undefined\n    if (signal) {\n        signalListener = removeListener.bind(null, list, callback, capture)\n        signal.addEventListener(\"abort\", signalListener)\n    }\n\n    const listener = createListener(\n        callback,\n        capture,\n        passive,\n        once,\n        signal,\n        signalListener,\n    )\n\n    if (list.cow) {\n        list.cow = false\n        list.listeners = [...list.listeners, listener]\n    } else {\n        list.listeners.push(listener)\n    }\n\n    return listener\n}\n\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n * @returns `true` if it mutated the list directly.\n */\nexport function removeListener(\n    list: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n): boolean {\n    const index = findIndexOfListener(list, callback, capture)\n    if (index !== -1) {\n        return removeListenerAt(list, index)\n    }\n    return false\n}\n\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param index The index of the target listener.\n * @param disableCow Disable copy-on-write if true.\n * @returns `true` if it mutated the `listeners` array directly.\n */\nexport function removeListenerAt(\n    list: ListenerList,\n    index: number,\n    disableCow = false,\n): boolean {\n    const listener = list.listeners[index]\n\n    // Set the removed flag.\n    setRemoved(listener)\n\n    // Dispose the abort signal listener if exists.\n    if (listener.signal) {\n        listener.signal.removeEventListener(\"abort\", listener.signalListener!)\n    }\n\n    // Remove it from the array.\n    if (list.cow && !disableCow) {\n        list.cow = false\n        list.listeners = list.listeners.filter((_, i) => i !== index)\n        return false\n    }\n    list.listeners.splice(index, 1)\n    return true\n}\n", "import { ListenerList } from \"./listener-list\"\n\n/**\n * The map from event types to each listener list.\n */\nexport interface ListenerListMap {\n    [type: string]: ListenerList | undefined\n}\n\n/**\n * Create a new `ListenerListMap` object.\n */\nexport function createListenerListMap(): ListenerListMap {\n    return Object.create(null)\n}\n\n/**\n * Get the listener list of the given type.\n * If the listener list has not been initialized, initialize and return it.\n * @param listenerMap The listener list map.\n * @param type The event type to get.\n */\nexport function ensureListenerList(\n    listenerMap: Record<string, ListenerList | undefined>,\n    type: string,\n): ListenerList {\n    return (listenerMap[type] ??= {\n        attrCallback: undefined,\n        attrListener: undefined,\n        cow: false,\n        listeners: [],\n    })\n}\n", "import { createInvalidStateError } from \"./dom-exception\"\nimport { Event, getEventInternalData } from \"./event\"\nimport { EventWrapper } from \"./event-wrapper\"\nimport { Global } from \"./global\"\nimport {\n    invokeCallback,\n    isCapture,\n    isOnce,\n    isPassive,\n    isRemoved,\n    Listener,\n} from \"./listener\"\nimport {\n    addListener,\n    findIndexOfListener,\n    removeListener,\n    removeListenerAt,\n} from \"./listener-list\"\nimport {\n    createListenerListMap,\n    ensureListenerList,\n    ListenerListMap,\n} from \"./listener-list-map\"\nimport { assertType, format } from \"./misc\"\nimport {\n    EventListenerWasDuplicated,\n    InvalidEventListener,\n    OptionWasIgnored,\n} from \"./warnings\"\n\n/**\n * An implementation of the `EventTarget` interface.\n * @see https://dom.spec.whatwg.org/#eventtarget\n */\nexport class EventTarget<\n    TEventMap extends Record<string, Event> = Record<string, Event>,\n    TMode extends \"standard\" | \"strict\" = \"standard\"\n> {\n    /**\n     * Initialize this instance.\n     */\n    constructor() {\n        internalDataMap.set(this, createListenerListMap())\n    }\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    addEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options?: EventTarget.AddOptions,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    addEventListener(\n        type: string,\n        callback?: EventTarget.FallbackEventListener<this, TMode>,\n        options?: EventTarget.AddOptions,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    addEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback:\n            | EventTarget.EventListener<this, TEventMap[T]>\n            | null\n            | undefined,\n        capture: boolean,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    addEventListener(\n        type: string,\n        callback: EventTarget.FallbackEventListener<this, TMode>,\n        capture: boolean,\n    ): void\n\n    // Implementation\n    addEventListener<T extends string & keyof TEventMap>(\n        type0: T,\n        callback0?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options0?: boolean | EventTarget.AddOptions,\n    ): void {\n        const listenerMap = $(this)\n        const {\n            callback,\n            capture,\n            once,\n            passive,\n            signal,\n            type,\n        } = normalizeAddOptions(type0, callback0, options0)\n        if (callback == null || signal?.aborted) {\n            return\n        }\n        const list = ensureListenerList(listenerMap, type)\n\n        // Find existing listener.\n        const i = findIndexOfListener(list, callback, capture)\n        if (i !== -1) {\n            warnDuplicate(list.listeners[i], passive, once, signal)\n            return\n        }\n\n        // Add the new listener.\n        addListener(list, callback, capture, passive, once, signal)\n    }\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    removeEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options?: EventTarget.Options,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    removeEventListener(\n        type: string,\n        callback?: EventTarget.FallbackEventListener<this, TMode>,\n        options?: EventTarget.Options,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    removeEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback:\n            | EventTarget.EventListener<this, TEventMap[T]>\n            | null\n            | undefined,\n        capture: boolean,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    removeEventListener(\n        type: string,\n        callback: EventTarget.FallbackEventListener<this, TMode>,\n        capture: boolean,\n    ): void\n\n    // Implementation\n    removeEventListener<T extends string & keyof TEventMap>(\n        type0: T,\n        callback0?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options0?: boolean | EventTarget.Options,\n    ): void {\n        const listenerMap = $(this)\n        const { callback, capture, type } = normalizeOptions(\n            type0,\n            callback0,\n            options0,\n        )\n        const list = listenerMap[type]\n\n        if (callback != null && list) {\n            removeListener(list, callback, capture)\n        }\n    }\n\n    /**\n     * Dispatch an event.\n     * @param event The `Event` object to dispatch.\n     */\n    dispatchEvent<T extends string & keyof TEventMap>(\n        event: EventTarget.EventData<TEventMap, TMode, T>,\n    ): boolean\n\n    /**\n     * Dispatch an event.\n     * @param event The `Event` object to dispatch.\n     */\n    dispatchEvent(event: EventTarget.FallbackEvent<TMode>): boolean\n\n    // Implementation\n    dispatchEvent(\n        e:\n            | EventTarget.EventData<TEventMap, TMode, string>\n            | EventTarget.FallbackEvent<TMode>,\n    ): boolean {\n        const list = $(this)[String(e.type)]\n        if (list == null) {\n            return true\n        }\n\n        const event = e instanceof Event ? e : EventWrapper.wrap(e)\n        const eventData = getEventInternalData(event, \"event\")\n        if (eventData.dispatchFlag) {\n            throw createInvalidStateError(\"This event has been in dispatching.\")\n        }\n\n        eventData.dispatchFlag = true\n        eventData.target = eventData.currentTarget = this\n\n        if (!eventData.stopPropagationFlag) {\n            const { cow, listeners } = list\n\n            // Set copy-on-write flag.\n            list.cow = true\n\n            // Call listeners.\n            for (let i = 0; i < listeners.length; ++i) {\n                const listener = listeners[i]\n\n                // Skip if removed.\n                if (isRemoved(listener)) {\n                    continue\n                }\n\n                // Remove this listener if has the `once` flag.\n                if (isOnce(listener) && removeListenerAt(list, i, !cow)) {\n                    // Because this listener was removed, the next index is the\n                    // same as the current value.\n                    i -= 1\n                }\n\n                // Call this listener with the `passive` flag.\n                eventData.inPassiveListenerFlag = isPassive(listener)\n                invokeCallback(listener, this, event)\n                eventData.inPassiveListenerFlag = false\n\n                // Stop if the `event.stopImmediatePropagation()` method was called.\n                if (eventData.stopImmediatePropagationFlag) {\n                    break\n                }\n            }\n\n            // Restore copy-on-write flag.\n            if (!cow) {\n                list.cow = false\n            }\n        }\n\n        eventData.target = null\n        eventData.currentTarget = null\n        eventData.stopImmediatePropagationFlag = false\n        eventData.stopPropagationFlag = false\n        eventData.dispatchFlag = false\n\n        return !eventData.canceledFlag\n    }\n}\n\nexport namespace EventTarget {\n    /**\n     * The event listener.\n     */\n    export type EventListener<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > = CallbackFunction<TEventTarget, TEvent> | CallbackObject<TEvent>\n\n    /**\n     * The event listener function.\n     */\n    export interface CallbackFunction<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > {\n        (this: TEventTarget, event: TEvent): void\n    }\n\n    /**\n     * The event listener object.\n     * @see https://dom.spec.whatwg.org/#callbackdef-eventlistener\n     */\n    export interface CallbackObject<TEvent extends Event> {\n        handleEvent(event: TEvent): void\n    }\n\n    /**\n     * The common options for both `addEventListener` and `removeEventListener` methods.\n     * @see https://dom.spec.whatwg.org/#dictdef-eventlisteneroptions\n     */\n    export interface Options {\n        capture?: boolean\n    }\n\n    /**\n     * The options for the `addEventListener` methods.\n     * @see https://dom.spec.whatwg.org/#dictdef-addeventlisteneroptions\n     */\n    export interface AddOptions extends Options {\n        passive?: boolean\n        once?: boolean\n        signal?: AbortSignal | null | undefined\n    }\n\n    /**\n     * The abort signal.\n     * @see https://dom.spec.whatwg.org/#abortsignal\n     */\n    export interface AbortSignal extends EventTarget<{ abort: Event }> {\n        readonly aborted: boolean\n        onabort: CallbackFunction<this, Event> | null\n    }\n\n    /**\n     * The event data to dispatch in strict mode.\n     */\n    export type EventData<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\",\n        TEventType extends string\n    > = TMode extends \"strict\"\n        ? IsValidEventMap<TEventMap> extends true\n            ? ExplicitType<TEventType> &\n                  Omit<TEventMap[TEventType], keyof Event> &\n                  Partial<Omit<Event, \"type\">>\n            : never\n        : never\n\n    /**\n     * Define explicit `type` property if `T` is a string literal.\n     * Otherwise, never.\n     */\n    export type ExplicitType<T extends string> = string extends T\n        ? never\n        : { readonly type: T }\n\n    /**\n     * The event listener type in standard mode.\n     * Otherwise, never.\n     */\n    export type FallbackEventListener<\n        TEventTarget extends EventTarget<any, any>,\n        TMode extends \"standard\" | \"strict\"\n    > = TMode extends \"standard\"\n        ? EventListener<TEventTarget, Event> | null | undefined\n        : never\n\n    /**\n     * The event type in standard mode.\n     * Otherwise, never.\n     */\n    export type FallbackEvent<\n        TMode extends \"standard\" | \"strict\"\n    > = TMode extends \"standard\" ? Event : never\n\n    /**\n     * Check if given event map is valid.\n     * It's valid if the keys of the event map are narrower than `string`.\n     */\n    export type IsValidEventMap<T> = string extends keyof T ? false : true\n}\n\nexport { $ as getEventTargetInternalData }\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Internal data for EventTarget\n */\ntype EventTargetInternalData = ListenerListMap\n\n/**\n * Internal data.\n */\nconst internalDataMap = new WeakMap<any, EventTargetInternalData>()\n\n/**\n * Get private data.\n * @param target The event target object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(target: any, name = \"this\"): EventTargetInternalData {\n    const retv = internalDataMap.get(target)\n    assertType(\n        retv != null,\n        \"'%s' must be an object that EventTarget constructor created, but got another one: %o\",\n        name,\n        target,\n    )\n    return retv\n}\n\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeAddOptions(\n    type: string,\n    callback: EventTarget.EventListener<any, any> | null | undefined,\n    options: boolean | EventTarget.AddOptions | undefined,\n): {\n    type: string\n    callback: EventTarget.EventListener<any, any> | undefined\n    capture: boolean\n    passive: boolean\n    once: boolean\n    signal: EventTarget.AbortSignal | undefined\n} {\n    assertCallback(callback)\n\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback ?? undefined,\n            capture: Boolean(options.capture),\n            passive: Boolean(options.passive),\n            once: Boolean(options.once),\n            signal: options.signal ?? undefined,\n        }\n    }\n\n    return {\n        type: String(type),\n        callback: callback ?? undefined,\n        capture: Boolean(options),\n        passive: false,\n        once: false,\n        signal: undefined,\n    }\n}\n\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeOptions(\n    type: string,\n    callback: EventTarget.EventListener<any, any> | null | undefined,\n    options: boolean | EventTarget.Options | undefined,\n): {\n    type: string\n    callback: EventTarget.EventListener<any, any> | undefined\n    capture: boolean\n} {\n    assertCallback(callback)\n\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback ?? undefined,\n            capture: Boolean(options.capture),\n        }\n    }\n\n    return {\n        type: String(type),\n        callback: callback ?? undefined,\n        capture: Boolean(options),\n    }\n}\n\n/**\n * Assert the type of 'callback' argument.\n * @param callback The callback to check.\n */\nfunction assertCallback(callback: any): void {\n    if (\n        typeof callback === \"function\" ||\n        (typeof callback === \"object\" &&\n            callback !== null &&\n            typeof callback.handleEvent === \"function\")\n    ) {\n        return\n    }\n    if (callback == null || typeof callback === \"object\") {\n        InvalidEventListener.warn(callback)\n        return\n    }\n\n    throw new TypeError(format(InvalidEventListener.message, [callback]))\n}\n\n/**\n * Print warning for duplicated.\n * @param listener The current listener that is duplicated.\n * @param passive The passive flag of the new duplicated listener.\n * @param once The once flag of the new duplicated listener.\n * @param signal The signal object of the new duplicated listener.\n */\nfunction warnDuplicate(\n    listener: Listener,\n    passive: boolean,\n    once: boolean,\n    signal: EventTarget.AbortSignal | undefined,\n): void {\n    EventListenerWasDuplicated.warn(\n        isCapture(listener) ? \"capture\" : \"bubble\",\n        listener.callback,\n    )\n\n    if (isPassive(listener) !== passive) {\n        OptionWasIgnored.warn(\"passive\")\n    }\n    if (isOnce(listener) !== once) {\n        OptionWasIgnored.warn(\"once\")\n    }\n    if (listener.signal !== signal) {\n        OptionWasIgnored.warn(\"signal\")\n    }\n}\n\n// Set enumerable\nconst keys = Object.getOwnPropertyNames(EventTarget.prototype)\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue\n    }\n    Object.defineProperty(EventTarget.prototype, keys[i], { enumerable: true })\n}\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof Global !== \"undefined\" &&\n    typeof Global.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype)\n}\n", "import { Event } from \"./event\"\nimport { EventTarget, getEventTargetInternalData } from \"./event-target\"\nimport { addListener, ListenerList, removeListener } from \"./listener-list\"\nimport { ensureListenerList } from \"./listener-list-map\"\nimport { InvalidAttributeHandler } from \"./warnings\"\n\n/**\n * Get the current value of a given event attribute.\n * @param target The `EventTarget` object to get.\n * @param type The event type.\n */\nexport function getEventAttributeValue<\n    TEventTarget extends EventTarget<any, any>,\n    TEvent extends Event\n>(\n    target: TEventTarget,\n    type: string,\n): EventTarget.CallbackFunction<TEventTarget, TEvent> | null {\n    const listMap = getEventTargetInternalData(target, \"target\")\n    return listMap[type]?.attrCallback ?? null\n}\n\n/**\n * Set an event listener to a given event attribute.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nexport function setEventAttributeValue(\n    target: EventTarget<any, any>,\n    type: string,\n    callback: EventTarget.CallbackFunction<any, any> | null,\n): void {\n    if (callback != null && typeof callback !== \"function\") {\n        InvalidAttributeHandler.warn(callback)\n    }\n\n    if (\n        typeof callback === \"function\" ||\n        (typeof callback === \"object\" && callback !== null)\n    ) {\n        upsertEventAttributeListener(target, type, callback)\n    } else {\n        removeEventAttributeListener(target, type)\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Update or insert the given event attribute handler.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction upsertEventAttributeListener<\n    TEventTarget extends EventTarget<any, any>\n>(\n    target: TEventTarget,\n    type: string,\n    callback: EventTarget.CallbackFunction<TEventTarget, any>,\n): void {\n    const list = ensureListenerList(\n        getEventTargetInternalData(target, \"target\"),\n        String(type),\n    )\n    list.attrCallback = callback\n\n    if (list.attrListener == null) {\n        list.attrListener = addListener(\n            list,\n            defineEventAttributeCallback(list),\n            false,\n            false,\n            false,\n            undefined,\n        )\n    }\n}\n\n/**\n * Remove the given event attribute handler.\n * @param target The `EventTarget` object to remove.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction removeEventAttributeListener(\n    target: EventTarget<any, any>,\n    type: string,\n): void {\n    const listMap = getEventTargetInternalData(target, \"target\")\n    const list = listMap[String(type)]\n    if (list && list.attrListener) {\n        removeListener(list, list.attrListener.callback, false)\n        list.attrCallback = list.attrListener = undefined\n    }\n}\n\n/**\n * Define the callback function for the given listener list object.\n * It calls `attrCallback` property if the property value is a function.\n * @param list The `ListenerList` object.\n */\nfunction defineEventAttributeCallback(\n    list: ListenerList,\n): EventTarget.CallbackFunction<any, any> {\n    return function (event) {\n        const callback = list.attrCallback\n        if (typeof callback === \"function\") {\n            callback.call(this, event)\n        }\n    }\n}\n", "import { Event } from \"./event\"\nimport {\n    getEventAttributeValue,\n    setEventAttributeValue,\n} from \"./event-attribute-handler\"\nimport { EventTarget } from \"./event-target\"\n\n/**\n * Define an `EventTarget` class that has event attibutes.\n * @param types The types to define event attributes.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nexport function defineCustomEventTarget<\n    TEventMap extends Record<string, Event>,\n    TMode extends \"standard\" | \"strict\" = \"standard\"\n>(\n    ...types: (string & keyof TEventMap)[]\n): defineCustomEventTarget.CustomEventTargetConstructor<TEventMap, TMode> {\n    class CustomEventTarget extends EventTarget {}\n    for (let i = 0; i < types.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, types[i])\n    }\n\n    return CustomEventTarget as any\n}\n\nexport namespace defineCustomEventTarget {\n    /**\n     * The interface of CustomEventTarget constructor.\n     */\n    export type CustomEventTargetConstructor<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\"\n    > = {\n        /**\n         * Create a new instance.\n         */\n        new (): CustomEventTarget<TEventMap, TMode>\n        /**\n         * prototype object.\n         */\n        prototype: CustomEventTarget<TEventMap, TMode>\n    }\n\n    /**\n     * The interface of CustomEventTarget.\n     */\n    export type CustomEventTarget<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\"\n    > = EventTarget<TEventMap, TMode> &\n        defineEventAttribute.EventAttributes<any, TEventMap>\n}\n\n/**\n * Define an event attribute.\n * @param target The `EventTarget` object to define an event attribute.\n * @param type The event type to define.\n * @param _eventClass Unused, but to infer `Event` class type.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nexport function defineEventAttribute<\n    TEventTarget extends EventTarget,\n    TEventType extends string,\n    TEventConstrucor extends typeof Event\n>(\n    target: TEventTarget,\n    type: TEventType,\n    _eventClass?: TEventConstrucor,\n): asserts target is TEventTarget &\n    defineEventAttribute.EventAttributes<\n        TEventTarget,\n        Record<TEventType, InstanceType<TEventConstrucor>>\n    > {\n    Object.defineProperty(target, `on${type}`, {\n        get() {\n            return getEventAttributeValue(this, type)\n        },\n        set(value) {\n            setEventAttributeValue(this, type, value)\n        },\n        configurable: true,\n        enumerable: true,\n    })\n}\n\nexport namespace defineEventAttribute {\n    /**\n     * Definition of event attributes.\n     */\n    export type EventAttributes<\n        TEventTarget extends EventTarget<any, any>,\n        TEventMap extends Record<string, Event>\n    > = {\n        [P in string &\n            keyof TEventMap as `on${P}`]: EventTarget.CallbackFunction<\n            TEventTarget,\n            TEventMap[P]\n        > | null\n    }\n}\n", "import { EventTarget, Event } from 'event-target-shim';\nimport xhr from 'xhr';\n// NOTE: Need duplicate imports for Typescript version compatibility reasons (CJP)\n/* tslint:disable-next-line no-duplicate-imports */\nimport type { XhrUrlConfig, XhrHeaders, XhrResponse } from 'xhr';\n\ntype XhrResponseLike = Partial<XhrResponse> & Pick<XhrResponse, 'statusCode'>;\n\nconst DEFAULT_CHUNK_SIZE = 30720;\nconst DEFAULT_MAX_CHUNK_SIZE = 512000; // in kB\nconst DEFAULT_MIN_CHUNK_SIZE = 256; // in kB\n\n// Predicate function that returns true if a given `chunkSize` is valid, otherwise false.\n// For `chunkSize` validity, we constrain by a min/max chunk size and conform to GCS:\n// \"The chunk size should be a multiple of 256 KiB (256 x 1024 bytes), unless it's the last\n// chunk that completes the upload.\" (See: https://cloud.google.com/storage/docs/performing-resumable-uploads)\nexport const isValidChunkSize = (\n  chunkSize: any,\n  {\n    minChunkSize = DEFAULT_MIN_CHUNK_SIZE,\n    maxChunkSize = DEFAULT_MAX_CHUNK_SIZE,\n  } = {}\n): chunkSize is number | null | undefined => {\n  return (\n    chunkSize == null ||\n    (typeof chunkSize === 'number' &&\n      chunkSize >= 256 &&\n      chunkSize % 256 === 0 &&\n      chunkSize >= minChunkSize &&\n      chunkSize <= maxChunkSize)\n  );\n};\n\n// Projection function that returns an error associated with invalid `chunkSize` values.\nexport const getChunkSizeError = (\n  chunkSize: any,\n  {\n    minChunkSize = DEFAULT_MIN_CHUNK_SIZE,\n    maxChunkSize = DEFAULT_MAX_CHUNK_SIZE,\n  } = {}\n) => {\n  return new TypeError(\n    `chunkSize ${chunkSize} must be a positive number in multiples of 256, between ${minChunkSize} and ${maxChunkSize}`\n  );\n};\n\nexport type ChunkedStreamIterableOptions = {\n  defaultChunkSize?: number;\n  minChunkSize?: number;\n  maxChunkSize?: number;\n};\n\nexport interface ChunkedIterable extends AsyncIterable<Blob> {\n  chunkSize: number;\n  readonly chunkByteSize: number;\n  readonly minChunkSize: number;\n  readonly maxChunkSize: number;\n  readonly error: Error | undefined;\n}\n\n// An Iterable that accepts a readableStream of binary data (Blob | Uint8Array) and provides\n// an asyncIterator which yields Blob values of the current chunkSize until done. Note that\n// chunkSize may change between iterations.\nexport class ChunkedStreamIterable implements ChunkedIterable {\n  protected _chunkSize: number | undefined;\n  protected defaultChunkSize: number;\n  protected _error: Error | undefined;\n  public readonly minChunkSize: number;\n  public readonly maxChunkSize: number;\n\n  constructor(\n    protected readableStream: ReadableStream<Uint8Array | Blob>,\n    options: ChunkedStreamIterableOptions = {}\n  ) {\n    if (!isValidChunkSize(options.defaultChunkSize, options)) {\n      throw getChunkSizeError(options.defaultChunkSize, options);\n    }\n    this.defaultChunkSize = options.defaultChunkSize ?? DEFAULT_CHUNK_SIZE;\n    this.minChunkSize = options.minChunkSize ?? DEFAULT_MIN_CHUNK_SIZE;\n    this.maxChunkSize = options.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE;\n  }\n\n  get chunkSize() {\n    return this._chunkSize ?? this.defaultChunkSize;\n  }\n\n  set chunkSize(value) {\n    if (!isValidChunkSize(value, this)) {\n      throw getChunkSizeError(value, this);\n    }\n    this._chunkSize = value;\n  }\n\n  get chunkByteSize() {\n    return this.chunkSize * 1024;\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<Blob> {\n    let chunk;\n    const reader = this.readableStream.getReader();\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          // Last chunk, if any bits remain\n          if (chunk) {\n            const outgoingChunk = chunk;\n            chunk = undefined;\n            yield outgoingChunk;\n          }\n          break;\n        }\n\n        const normalizedBlobChunk =\n          value instanceof Uint8Array\n            ? new Blob([value], { type: 'application/octet-stream' })\n            : value;\n\n        chunk = chunk\n          ? new Blob([chunk, normalizedBlobChunk])\n          : normalizedBlobChunk;\n\n        // NOTE: Since we don't know how big the next chunk needs to be, we should\n        // just have a single blob that we \"peel away bytes from\" for each chunk\n        // as we iterate.\n        while (chunk) {\n          if (chunk.size === this.chunkByteSize) {\n            const outgoingChunk = chunk;\n            chunk = undefined;\n            yield outgoingChunk;\n            break;\n          } else if (chunk.size < this.chunkByteSize) {\n            break;\n          } else {\n            const outgoingChunk = chunk.slice(0, this.chunkByteSize);\n            chunk = chunk.slice(this.chunkByteSize);\n            yield outgoingChunk;\n          }\n        }\n      }\n    } catch (e) {\n      // There are edge case errors when attempting to read() from ReadableStream reader.\n      this._error = e;\n    } finally {\n      // Last chunk, if any bits remain\n      if (chunk) {\n        const outgoingChunk = chunk;\n        chunk = undefined;\n        yield outgoingChunk;\n      }\n      reader.releaseLock();\n      return;\n    }\n  }\n}\n\nexport class ChunkedFileIterable implements ChunkedIterable {\n  protected _chunkSize: number | undefined;\n  protected defaultChunkSize: number;\n  protected _error: Error | undefined;\n  public readonly minChunkSize: number;\n  public readonly maxChunkSize: number;\n\n  constructor(\n    protected file: File,\n    options: ChunkedStreamIterableOptions = {}\n  ) {\n    if (!isValidChunkSize(options.defaultChunkSize, options)) {\n      throw getChunkSizeError(options.defaultChunkSize, options);\n    }\n    this.defaultChunkSize = options.defaultChunkSize ?? DEFAULT_CHUNK_SIZE;\n    this.minChunkSize = options.minChunkSize ?? DEFAULT_MIN_CHUNK_SIZE;\n    this.maxChunkSize = options.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE;\n  }\n\n  get chunkSize() {\n    return this._chunkSize ?? this.defaultChunkSize;\n  }\n\n  set chunkSize(value) {\n    if (!isValidChunkSize(value, this)) {\n      throw getChunkSizeError(value, this);\n    }\n    this._chunkSize = value;\n  }\n\n  get chunkByteSize() {\n    return this.chunkSize * 1024;\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<Blob> {\n    const reader = new FileReader();\n    let nextChunkRangeStart = 0;\n    /**\n     * Get portion of the file of x bytes corresponding to chunkSize\n     */\n    const getChunk = () => {\n      return new Promise<Blob | undefined>((resolve) => {\n        if (nextChunkRangeStart >= this.file.size) {\n          resolve(undefined);\n          return;\n        }\n        // We either want to slize a \"chunkByteSize-worth\" of the file or\n        // slice to the end of the file (if less than a \"chunkByteSize-worth\" is left)\n        const length = Math.min(\n          this.chunkByteSize,\n          this.file.size - nextChunkRangeStart\n        );\n        reader.onload = () => {\n          if (reader.result !== null) {\n            resolve(\n              new Blob([reader.result], {\n                type: 'application/octet-stream',\n              })\n            );\n          } else {\n            resolve(undefined);\n          }\n        };\n\n        reader.readAsArrayBuffer(\n          this.file.slice(nextChunkRangeStart, nextChunkRangeStart + length)\n        );\n      });\n    };\n    try {\n      while (true) {\n        const nextChunk = await getChunk();\n        if (!!nextChunk) {\n          nextChunkRangeStart += nextChunk.size;\n          yield nextChunk;\n        } else {\n          break;\n        }\n      }\n    } catch (e) {\n      this._error = e;\n    }\n  }\n}\n\nconst SUCCESSFUL_CHUNK_UPLOAD_CODES = [200, 201, 202, 204, 308];\nconst TEMPORARY_ERROR_CODES = [408, 502, 503, 504]; // These error codes imply a chunk may be retried\nconst RESUME_INCOMPLETE_CODES = [308];\n\ntype UploadPredOptions = {\n  retryCodes?: typeof TEMPORARY_ERROR_CODES;\n  attempts: number;\n  attemptCount: number;\n};\nconst isSuccessfulChunkUpload = (\n  res: XhrResponseLike | undefined,\n  _options?: any\n): res is XhrResponse =>\n  !!res && SUCCESSFUL_CHUNK_UPLOAD_CODES.includes(res.statusCode);\n\nconst isRetriableChunkUpload = (\n  res: XhrResponseLike | undefined,\n  { retryCodes = TEMPORARY_ERROR_CODES }: UploadPredOptions\n) => !res || retryCodes.includes(res.statusCode);\n\nconst isFailedChunkUpload = (\n  res: XhrResponseLike | undefined,\n  options: UploadPredOptions\n): res is XhrResponseLike => {\n  return (\n    options.attemptCount >= options.attempts ||\n    !(isSuccessfulChunkUpload(res) || isRetriableChunkUpload(res, options))\n  );\n};\n\n/**\n * Checks if an upload chunk was partially received (HTTP 308) and needs a retry.\n * Validates against the 'Range' header to ensure the full chunk was processed.\n */\nexport const isIncompleteChunkUploadNeedingRetry = (\n  res: XhrResponseLike | undefined,\n  _options?: any\n): res is XhrResponseLike => {\n  if (\n    !res ||\n    !RESUME_INCOMPLETE_CODES.includes(res.statusCode) ||\n    !res.headers?.['range']\n  ) {\n    return false;\n  }\n\n  const range = res.headers['range'].match(/bytes=(\\d+)-(\\d+)/);\n  if (!range) {\n    return false;\n  }\n\n  const endByte = parseInt(range[2], 10);\n  return endByte !== _options.currentChunkEndByte;\n};\n\ntype EventName =\n  | 'attempt'\n  | 'attemptFailure'\n  | 'chunkSuccess'\n  | 'error'\n  | 'offline'\n  | 'online'\n  | 'progress'\n  | 'success';\n\n// NOTE: This and the EventTarget definition below could be more precise\n// by e.g. typing the detail of the CustomEvent per EventName.\ntype UpchunkEvent = CustomEvent & Event<EventName>;\n\ntype AllowedMethods = 'PUT' | 'POST' | 'PATCH';\n\nexport interface UpChunkOptions {\n  endpoint: string | ((file?: File) => Promise<string>);\n  file: File;\n  method?: AllowedMethods;\n  headers?: XhrHeaders | (() => XhrHeaders) | (() => Promise<XhrHeaders>);\n  maxFileSize?: number;\n  chunkSize?: number;\n  attempts?: number;\n  delayBeforeAttempt?: number;\n  retryCodes?: number[];\n  dynamicChunkSize?: boolean;\n  maxChunkSize?: number;\n  minChunkSize?: number;\n  useLargeFileWorkaround?: boolean;\n}\n\nexport class UpChunk {\n  public static createUpload(options: UpChunkOptions) {\n    return new UpChunk(options);\n  }\n\n  public endpoint: string | ((file?: File) => Promise<string>);\n  public file: File;\n  public headers: XhrHeaders | (() => XhrHeaders) | (() => Promise<XhrHeaders>);\n  public method: AllowedMethods;\n  public attempts: number;\n  public delayBeforeAttempt: number;\n  public retryCodes: number[];\n  public dynamicChunkSize: boolean;\n  protected chunkedIterable: ChunkedIterable;\n  protected chunkedIterator;\n\n  protected pendingChunk?: Blob;\n  private chunkCount: number;\n  private maxFileBytes: number;\n  private endpointValue: string;\n  private totalChunks: number;\n  private attemptCount: number;\n  private _offline: boolean;\n  private _paused: boolean;\n  private success: boolean;\n  private currentXhr?: XMLHttpRequest;\n  private lastChunkStart: Date;\n  private nextChunkRangeStart: number;\n\n  private eventTarget: EventTarget<Record<EventName, UpchunkEvent>>;\n\n  constructor(options: UpChunkOptions) {\n    this.eventTarget = new EventTarget();\n\n    this.endpoint = options.endpoint;\n    this.file = options.file;\n\n    this.headers = options.headers || ({} as XhrHeaders);\n    this.method = options.method || 'PUT';\n    this.attempts = options.attempts || 5;\n    this.delayBeforeAttempt = options.delayBeforeAttempt || 1;\n    this.retryCodes = options.retryCodes || TEMPORARY_ERROR_CODES;\n    this.dynamicChunkSize = options.dynamicChunkSize || false;\n\n    this.maxFileBytes = (options.maxFileSize || 0) * 1024;\n    this.chunkCount = 0;\n    this.attemptCount = 0;\n    // Initialize offline to the current offline state, where\n    // offline is false if\n    // 1. we're not running in the browser (aka window is undefined) -OR-\n    // 2. we're not online (as advertised by navigator.onLine)\n    this._offline = typeof window !== 'undefined' && !window.navigator.onLine;\n    this._paused = false;\n    this.success = false;\n    this.nextChunkRangeStart = 0;\n\n    if (options.useLargeFileWorkaround) {\n      const readableStreamErrorCallback = (event: CustomEvent) => {\n        // In this case, assume the error is a result of file reading via ReadableStream.\n        // Retry using ChunkedFileIterable, which reads the file into memory instead\n        // of a stream.\n        if (this.chunkedIterable.error) {\n          console.warn(\n            `Unable to read file of size ${this.file.size} bytes via a ReadableStream. Falling back to in-memory FileReader!`\n          );\n          event.stopImmediatePropagation();\n\n          // Re-set everything up with the fallback iterable and corresponding\n          // iterator\n          this.chunkedIterable = new ChunkedFileIterable(this.file, {\n            ...options,\n            defaultChunkSize: options.chunkSize,\n          });\n          this.chunkedIterator = this.chunkedIterable[Symbol.asyncIterator]();\n          this.getEndpoint().then(() => {\n            this.sendChunks();\n          });\n          this.off('error', readableStreamErrorCallback);\n        }\n      };\n      this.on('error', readableStreamErrorCallback);\n    }\n\n    // Types appear to be getting confused in env setup, using the overloaded NodeJS Blob definition, which uses NodeJS.ReadableStream instead\n    // of the DOM type definitions. For definitions, See consumers.d.ts vs. lib.dom.d.ts. (CJP)\n    this.chunkedIterable = new ChunkedStreamIterable(\n      this.file.stream() as unknown as ReadableStream<Uint8Array>,\n      { ...options, defaultChunkSize: options.chunkSize }\n    );\n    this.chunkedIterator = this.chunkedIterable[Symbol.asyncIterator]();\n\n    // NOTE: Since some of upchunk's properties defer \"source of truth\" to\n    // chunkedIterable, we need to do these after it's been created (CJP).\n    this.totalChunks = Math.ceil(this.file.size / this.chunkByteSize);\n    this.validateOptions();\n\n    this.getEndpoint().then(() => this.sendChunks());\n\n    // restart sync when back online\n    // trigger events when offline/back online\n    if (typeof window !== 'undefined') {\n      window.addEventListener('online', () => {\n        if (!this.offline) return;\n\n        this._offline = false;\n        this.dispatch('online');\n        this.sendChunks();\n      });\n\n      window.addEventListener('offline', () => {\n        if (this.offline) return;\n\n        this._offline = true;\n        this.dispatch('offline');\n      });\n    }\n  }\n\n  protected get maxChunkSize() {\n    return this.chunkedIterable?.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE;\n  }\n\n  protected get minChunkSize() {\n    return this.chunkedIterable?.minChunkSize ?? DEFAULT_MIN_CHUNK_SIZE;\n  }\n\n  public get chunkSize() {\n    return this.chunkedIterable?.chunkSize ?? DEFAULT_CHUNK_SIZE;\n  }\n\n  public set chunkSize(value) {\n    this.chunkedIterable.chunkSize = value;\n  }\n\n  public get chunkByteSize() {\n    return this.chunkedIterable.chunkByteSize;\n  }\n\n  public get totalChunkSize() {\n    return Math.ceil(this.file.size / this.chunkByteSize);\n  }\n\n  /**\n   * Subscribe to an event\n   */\n  public on(eventName: EventName, fn: (event: CustomEvent) => void) {\n    this.eventTarget.addEventListener(eventName, fn as EventListener);\n  }\n\n  /**\n   * Subscribe to an event once\n   */\n  public once(eventName: EventName, fn: (event: CustomEvent) => void) {\n    this.eventTarget.addEventListener(eventName, fn as EventListener, {\n      once: true,\n    });\n  }\n\n  /**\n   * Unsubscribe to an event\n   */\n  public off(eventName: EventName, fn: (event: CustomEvent) => void) {\n    this.eventTarget.removeEventListener(eventName, fn as EventListener);\n  }\n\n  public get offline() {\n    return this._offline;\n  }\n\n  public get paused() {\n    return this._paused;\n  }\n\n  public abort() {\n    this.pause();\n    this.currentXhr?.abort();\n  }\n\n  public pause() {\n    this._paused = true;\n  }\n\n  public resume() {\n    if (this._paused) {\n      this._paused = false;\n\n      this.sendChunks();\n    }\n  }\n\n  public get successfulPercentage() {\n    return this.nextChunkRangeStart / this.file.size;\n  }\n\n  /**\n   * Dispatch an event\n   */\n  private dispatch(eventName: EventName, detail?: any) {\n    const event: UpchunkEvent = new CustomEvent(eventName, {\n      detail,\n    }) as UpchunkEvent;\n\n    this.eventTarget.dispatchEvent(event);\n  }\n\n  /**\n   * Validate options and throw errors if expectations are violated.\n   */\n  private validateOptions() {\n    if (\n      !this.endpoint ||\n      (typeof this.endpoint !== 'function' && typeof this.endpoint !== 'string')\n    ) {\n      throw new TypeError(\n        'endpoint must be defined as a string or a function that returns a promise'\n      );\n    }\n    if (!(this.file instanceof File)) {\n      throw new TypeError('file must be a File object');\n    }\n    if (\n      this.headers &&\n      typeof this.headers !== 'function' &&\n      typeof this.headers !== 'object'\n    ) {\n      throw new TypeError(\n        'headers must be null, an object, or a function that returns an object or a promise'\n      );\n    }\n    if (\n      !isValidChunkSize(this.chunkSize, {\n        maxChunkSize: this.maxChunkSize,\n        minChunkSize: this.minChunkSize,\n      })\n    ) {\n      throw getChunkSizeError(this.chunkSize, {\n        maxChunkSize: this.maxChunkSize,\n        minChunkSize: this.minChunkSize,\n      });\n    }\n    if (\n      this.maxChunkSize &&\n      (typeof this.maxChunkSize !== 'number' ||\n        this.maxChunkSize < 256 ||\n        this.maxChunkSize % 256 !== 0 ||\n        this.maxChunkSize < this.chunkSize ||\n        this.maxChunkSize < this.minChunkSize)\n    ) {\n      throw new TypeError(\n        `maxChunkSize must be a positive number in multiples of 256, and larger than or equal to both ${this.minChunkSize} and ${this.chunkSize}`\n      );\n    }\n    if (\n      this.minChunkSize &&\n      (typeof this.minChunkSize !== 'number' ||\n        this.minChunkSize < 256 ||\n        this.minChunkSize % 256 !== 0 ||\n        this.minChunkSize > this.chunkSize ||\n        this.minChunkSize > this.maxChunkSize)\n    ) {\n      throw new TypeError(\n        `minChunkSize must be a positive number in multiples of 256, and smaller than ${this.chunkSize} and ${this.maxChunkSize}`\n      );\n    }\n    if (this.maxFileBytes > 0 && this.maxFileBytes < this.file.size) {\n      throw new Error(\n        `file size exceeds maximum (${this.file.size} > ${this.maxFileBytes})`\n      );\n    }\n    if (\n      this.attempts &&\n      (typeof this.attempts !== 'number' || this.attempts <= 0)\n    ) {\n      throw new TypeError('retries must be a positive number');\n    }\n    if (\n      this.delayBeforeAttempt &&\n      (typeof this.delayBeforeAttempt !== 'number' ||\n        this.delayBeforeAttempt < 0)\n    ) {\n      throw new TypeError('delayBeforeAttempt must be a positive number');\n    }\n  }\n\n  /**\n   * Endpoint can either be a URL or a function that returns a promise that resolves to a string.\n   */\n  private getEndpoint() {\n    if (typeof this.endpoint === 'string') {\n      this.endpointValue = this.endpoint;\n      return Promise.resolve(this.endpoint);\n    }\n\n    return this.endpoint(this.file).then((value) => {\n      this.endpointValue = value;\n      return this.endpointValue;\n    });\n  }\n\n  private xhrPromise(options: XhrUrlConfig): Promise<XhrResponse> {\n    const beforeSend = (xhrObject: XMLHttpRequest) => {\n      xhrObject.upload.onprogress = (event: ProgressEvent) => {\n        const remainingChunks = this.totalChunks - this.chunkCount;\n        const percentagePerChunk =\n          (this.file.size - this.nextChunkRangeStart) /\n          this.file.size /\n          remainingChunks;\n        const currentChunkProgress =\n          event.loaded / (event.total ?? this.chunkByteSize);\n        const chunkPercentage = currentChunkProgress * percentagePerChunk;\n        // NOTE: Since progress events are \"eager\" and do not (yet) have sufficient context\n        // to \"know\" if the request was e.g. successful, we need to \"recompute\"/\"rewind\"\n        // progress if/when we detect failures. See failedChunkUploadCb(), below. (CJP)\n        this.dispatch(\n          'progress',\n          Math.min((this.successfulPercentage + chunkPercentage) * 100, 100)\n        );\n      };\n    };\n\n    return new Promise((resolve, reject) => {\n      this.currentXhr = xhr({ ...options, beforeSend }, (err, resp) => {\n        this.currentXhr = undefined;\n        // NOTE: For at least some `err` cases, resp will still carry information. We may want to consider passing that on somehow\n        // in our Promise reject (or instead of err) (CJP)\n        // See: https://github.com/naugtur/xhr/blob/master/index.js#L93-L100\n        if (err) {\n          return reject(err);\n        }\n\n        return resolve(resp);\n      });\n    });\n  }\n\n  /**\n   * Send chunk of the file with appropriate headers\n   */\n  protected async sendChunk(chunk: Blob) {\n    const rangeStart = this.nextChunkRangeStart;\n    const rangeEnd = rangeStart + chunk.size - 1;\n    const extraHeaders = await (typeof this.headers === 'function'\n      ? this.headers()\n      : this.headers);\n\n    const headers = {\n      ...extraHeaders,\n      'Content-Type': this.file.type,\n      'Content-Range': `bytes ${rangeStart}-${rangeEnd}/${this.file.size}`,\n    };\n\n    this.dispatch('attempt', {\n      chunkNumber: this.chunkCount,\n      totalChunks: this.totalChunks,\n      chunkSize: this.chunkSize,\n    });\n\n    return this.xhrPromise({\n      headers,\n      url: this.endpointValue,\n      method: this.method,\n      body: chunk,\n    });\n  }\n\n  protected async sendChunkWithRetries(chunk: Blob): Promise<boolean> {\n    // What to do if a chunk was successfully uploaded\n    const successfulChunkUploadCb = async (res: XhrResponse, _chunk?: Blob) => {\n      // Side effects\n      const lastChunkEnd = new Date();\n      const lastChunkInterval =\n        (lastChunkEnd.getTime() - this.lastChunkStart.getTime()) / 1000;\n\n      this.dispatch('chunkSuccess', {\n        chunk: this.chunkCount,\n        chunkSize: this.chunkSize,\n        attempts: this.attemptCount,\n        timeInterval: lastChunkInterval,\n        response: res,\n      });\n\n      this.attemptCount = 0;\n      this.chunkCount = (this.chunkCount ?? 0) + 1;\n      this.nextChunkRangeStart = this.nextChunkRangeStart + this.chunkByteSize;\n      if (this.dynamicChunkSize) {\n        let unevenChunkSize = this.chunkSize;\n        if (lastChunkInterval < 10) {\n          unevenChunkSize = Math.min(this.chunkSize * 2, this.maxChunkSize);\n        } else if (lastChunkInterval > 30) {\n          unevenChunkSize = Math.max(this.chunkSize / 2, this.minChunkSize);\n        }\n        // ensure it's a multiple of 256k\n        this.chunkSize = Math.ceil(unevenChunkSize / 256) * 256;\n\n        // Re-estimate the total number of chunks, by adding the completed\n        // chunks to the remaining chunks\n        const remainingChunks =\n          (this.file.size - this.nextChunkRangeStart) / this.chunkByteSize;\n        this.totalChunks = Math.ceil(this.chunkCount + remainingChunks);\n      }\n\n      return true;\n    };\n\n    // What to do if a chunk upload failed, potentially after retries\n    const failedChunkUploadCb = async (res: XhrResponseLike, _chunk?: Blob) => {\n      this.dispatch('progress', Math.min(this.successfulPercentage * 100, 100));\n      // Side effects\n      this.dispatch('error', {\n        message: `Server responded with ${res.statusCode}. Stopping upload.`,\n        chunk: this.chunkCount,\n        attempts: this.attemptCount,\n        response: res,\n      });\n\n      return false;\n    };\n\n    // What to do if a chunk upload failed but is retriable and hasn't exceeded retry\n    // count\n    const retriableChunkUploadCb = async (\n      res: XhrResponseLike | undefined,\n      _chunk?: Blob\n    ) => {\n      // Side effects\n      this.dispatch('attemptFailure', {\n        message: `An error occured uploading chunk ${this.chunkCount}. ${\n          this.attempts - this.attemptCount\n        } retries left.`,\n        chunkNumber: this.chunkCount,\n        attemptsLeft: this.attempts - this.attemptCount,\n        response: res,\n      });\n\n      return new Promise<boolean>((resolve) => {\n        setTimeout(async () => {\n          // Handle mid-flight _paused/offline cases here by storing the\n          // \"still retriable but yet to be uploaded chunk\" in state.\n          // See also: `sendChunks()`\n          if (this._paused || this.offline) {\n            this.pendingChunk = chunk;\n            resolve(false);\n            return;\n          }\n          const chunkUploadSuccess = await this.sendChunkWithRetries(chunk);\n          resolve(chunkUploadSuccess);\n        }, this.delayBeforeAttempt * 1000);\n      });\n    };\n\n    let res: XhrResponseLike | undefined;\n    try {\n      this.attemptCount = this.attemptCount + 1;\n      this.lastChunkStart = new Date();\n      res = await this.sendChunk(chunk);\n    } catch (err: unknown) {\n      // Account for failed attempts due to becoming offline while making a request.\n      if (typeof (err as any)?.statusCode === 'number') {\n        res = err as XhrResponseLike;\n      }\n    }\n    const options = {\n      retryCodes: this.retryCodes,\n      attemptCount: this.attemptCount,\n      attempts: this.attempts,\n      currentChunkEndByte: this.nextChunkRangeStart + chunk.size - 1, // end byte is inclusive\n    };\n    if (isIncompleteChunkUploadNeedingRetry(res, options)) {\n      return retriableChunkUploadCb(res, chunk);\n    }\n    if (isSuccessfulChunkUpload(res, options)) {\n      return successfulChunkUploadCb(res, chunk);\n    }\n    if (isFailedChunkUpload(res, options)) {\n      return failedChunkUploadCb(res, chunk);\n    }\n    // Retriable case\n    return retriableChunkUploadCb(res, chunk);\n  }\n\n  /**\n   * Manage the whole upload by calling getChunk & sendChunk\n   * handle errors & retries and dispatch events\n   */\n  private async sendChunks() {\n    // A \"pending chunk\" is a chunk that was unsuccessful but still retriable when\n    // uploading was _paused or the env is offline. Since this may be the last chunk,\n    // we account for it outside of the loop.\n    if (this.pendingChunk && !(this._paused || this.offline)) {\n      const chunk = this.pendingChunk;\n      this.pendingChunk = undefined;\n      const chunkUploadSuccess = await this.sendChunkWithRetries(chunk);\n      if (this.success && chunkUploadSuccess) {\n        this.dispatch('success');\n      }\n    }\n\n    while (!(this.success || this._paused || this.offline)) {\n      const { value: chunk, done } = await this.chunkedIterator.next();\n      // NOTE: When `done`, `chunk` is undefined, so default `chunkUploadSuccess`\n      // to be `true` on this condition, otherwise `false`.\n      let chunkUploadSuccess = !chunk && done;\n      if (chunk) {\n        chunkUploadSuccess = await this.sendChunkWithRetries(chunk);\n      }\n\n      if (this.chunkedIterable.error) {\n        chunkUploadSuccess = false;\n        this.dispatch('error', {\n          message: `Unable to read file of size ${this.file.size} bytes. Try loading from another browser.`,\n        });\n        return;\n      }\n      // NOTE: Need to disambiguate \"last chunk to upload\" (done) vs. \"successfully\"\n      // uploaded last chunk to upload\" (depends on status of sendChunkWithRetries),\n      // specifically for \"pending chunk\" cases for the last chunk.\n      this.success = !!done;\n      if (this.success && chunkUploadSuccess) {\n        this.dispatch('success');\n      }\n      if (!chunkUploadSuccess) {\n        return;\n      }\n    }\n  }\n}\n\nexport function createUpload(options: UpChunkOptions) {\n  return UpChunk.createUpload(options);\n}\n"],
  "mappings": "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",
  "names": []
}
